
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Neopolitan Welcome Email</title>
  <!-- Designed by https://github.com/kaytcat -->
  <!-- Robot header image designed by Freepik.com -->

  
  <style type="text/css" media="screen">
@media screen {
  td,
h1,
h2,
h3 {
    font-family: 'Droid Sans', 'Helvetica Neue', 'Arial', 'sans-serif' !important;
  }
}
</style>

  <style type="text/css" media="only screen and (max-width: 480px)">
@media only screen and (max-width: 480px) {
  table[class="w320"] {
    width: 320px !important;
  }
}
</style>
</head>
<body class="body" dir="ltr" style="line-height: 1.7; -webkit-font-smoothing: antialiased; width: 100%; height: 100%; color: #37302d; font-size: 16px; padding: 0; margin: 0; display: block; background: #ffffff; -webkit-text-size-adjust: none;" bgcolor="#ffffff">
<!-- Support for Gmail Go-To Actions -->

<table align="center" cellpadding="0" cellspacing="0" width="100%" height="100%" style="border-collapse: collapse;">
  <tr>
    <td align="center" valign="top" bgcolor="#ffffff" width="100%" style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center;">
      <center>
        <table style="margin: 0 auto; border-collapse: collapse;" cellpadding="0" cellspacing="0" width="600" class="w320">
          <tr>
            <td align="center" valign="top" style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center;">
                <table style="margin: 10px auto; border-collapse: collapse;" cellpadding="0" cellspacing="0" width="100%">
                  <tr>
                    <td class="branding" style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; font-size: 30px; text-align: center;" align="center">
                        <a href="http://intense-stream-90411.herokuapp.com" target="_blank" style="text-decoration: none; border: 0; outline: none; color: inherit;">
                            
                                valentyna
                            
                        </a>
                    </td>
                  </tr>
                </table>

                <table style="margin: 0 auto; border-radius: 3px 3px 0 0; padding: 0 15px; border-collapse: collapse;" cellpadding="0" cellspacing="0" width="100%" bgcolor="#4dbfbf">
                  <tr>
                    <td class="headline" style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center; color: #ffffff; font-size: 36px;" align="center">
                      <div style="margin-top: 30px">
                        Hi valentyna,
                      </div>
                    </td>
                  </tr>
                  <tr>
                    <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center; color: #003C3C;" align="center">
                      <br>
                        <table style="margin: 0 auto; border-collapse: collapse;" cellpadding="0" cellspacing="0" width="70%">
                            <tr>
                                <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center; padding: 0 15px;" align="center">
                                  
                                                                          <p>Your score is 4 %</p>
                                                                      

                                  <!-- Dictionary -->
                                  
                                </td>
                            </tr>
                      </table>
                    </td>
                  </tr>
                    <tr>
                        <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center; color: #003C3C;" align="center">
                            <!-- Table -->
                            
                                                              <center>
                                <br>
                                <h3 style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; margin: 0;"></h3>
                                <table style="margin: 0 auto; border-collapse: collapse;" cellpadding="0" cellspacing="0" width="70%">
                                <tr>
                                    <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center;" align="center">
                                      <table class="data-table" width="100%" cellpadding="0" cellspacing="0" style="font-size: 14px; border-collapse: collapse;">
                                          <tr>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>__parentArray</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>__index</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$isDocumentArrayElement</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>IsNew</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Errors</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$locals</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$op</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>_doc</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>QuestionId</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Question</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Answer</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>RightAnswer</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>_id</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Id</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Schema</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Constructor</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$basePath</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__originalValidate</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__save</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__validate</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__remove</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__deleteOne</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__init</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>ToBSON</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$setIndex</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>MarkModified</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Populate</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Save</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Remove</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Update</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Inspect</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Invalidate</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$markValid</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$ignore</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$isValid</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>OwnerDocument</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__fullPath</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Parent</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$parent</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>ParentArray</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>On</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Once</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Emit</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Listeners</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>RemoveListener</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>SetMaxListeners</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>RemoveAllListeners</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>AddListener</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__buildDoc</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Init</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>UpdateOne</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>ReplaceOne</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$session</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Overwrite</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$set</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Set</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__shouldModify</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__set</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__getValue</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__setValue</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Get</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__path</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>UnmarkModified</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>DirectModifiedPaths</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$isEmpty</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>ModifiedPaths</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>IsModified</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$isDefault</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$isDeleted</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>IsDirectModified</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>IsInit</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>IsSelected</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__isSelected</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>IsDirectSelected</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Validate</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>ValidateSync</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__reset</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__undoReset</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__dirty</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__setSchema</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__getArrayPathsToValidate</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__getAllSubdocs</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$__handleReject</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>$toObject</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>ToObject</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>ToJSON</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>ToString</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Equals</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>ExecPopulate</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Populated</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>Depopulate</p>
                                              </th>
                                              
                                              <th style="text-align: left; padding: 0 5px; border-bottom: 1px solid rgba(0, 74, 74, 0.3);" align="left">
                                                  <p>GetChanges</p>
                                              </th>
                                              
                                          </tr>
                                          
                                          <tr>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  {
  _id: 60735418b255ff0b80680324,
  questionId: 15,
  question: 'What is formal testing?',
  answer: 'Verification of software, according to the test plan, test procedures and relevant documentation, taking into account the wishes of the client',
  rightAnswer: false
},{
  _id: 60735418b255ff0b80680325,
  questionId: 8,
  question: "Agile's main ideas",
  answer: 'All options are incorrect',
  rightAnswer: false
},{
  _id: 60735418b255ff0b80680326,
  questionId: 22,
  question: 'This is a comprehensive user testing of concurrent access to an application to verify the impact on a code, module or database. Mainly detects deadlocks in code.',
  answer: 'Currency testing',
  rightAnswer: true
},{
  _id: 60735418b255ff0b80680327,
  questionId: 18,
  question: 'Which of the following is superfluous',
  answer: 'Check list',
  rightAnswer: false
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  0
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  true
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  false
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  15
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  What is formal testing?
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  Verification of software, according to the test plan, test procedures and relevant documentation, taking into account the wishes of the client
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  false
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  60735418b255ff0b80680324
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  60735418b255ff0b80680324
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function EmbeddedDocument() {
    Subdocument.apply(this, arguments);

    this.$session(this.ownerDocument().$session());
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  questions
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options, callback) {
  if (typeof pathsToValidate === 'function') {
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }

  const _this = this;
  const _complete = () => {
    let validationError = this.$__.validationError;
    this.$__.validationError = undefined;

    if (shouldValidateModifiedOnly && validationError != null) {
      // Remove any validation errors that aren't from modified paths
      const errors = Object.keys(validationError.errors);
      for (const errPath of errors) {
        if (!this.isModified(errPath)) {
          delete validationError.errors[errPath];
        }
      }
      if (Object.keys(validationError.errors).length === 0) {
        validationError = void 0;
      }
    }

    this.$__.cachedRequired = {};
    this.emit('validate', _this);
    this.constructor.emit('validate', _this);

    this.$__.validating = null;
    if (validationError) {
      for (const key in validationError.errors) {
        // Make sure cast errors persist
        if (!this[documentArrayParent] &&
            validationError.errors[key] instanceof MongooseError.CastError) {
          this.invalidate(key, validationError.errors[key]);
        }
      }

      return validationError;
    }
  };

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];
  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  }
  if (paths.length === 0) {
    return process.nextTick(function() {
      const error = _complete();
      if (error) {
        return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
          callback(error);
        });
      }
      callback(null, _this);
    });
  }

  const validated = {};
  let total = 0;

  const complete = function() {
    const error = _complete();
    if (error) {
      return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
        callback(error);
      });
    }
    callback(null, _this);
  };

  const validatePath = function(path) {
    if (path == null || validated[path]) {
      return;
    }

    validated[path] = true;
    total++;

    process.nextTick(function() {
      const schemaType = _this.schema.path(path);

      if (!schemaType) {
        return --total || complete();
      }

      // If user marked as invalid or there was a cast error, don't validate
      if (!_this.$isValid(path)) {
        --total || complete();
        return;
      }

      let val = _this.$__getValue(path);

      // If you `populate()` and get back a null value, required validators
      // shouldn't fail (gh-8018). We should always fall back to the populated
      // value.
      let pop;
      if (val == null && (pop = _this.populated(path))) {
        val = pop;
      }
      const scope = path in _this.$__.pathsToScopes ?
        _this.$__.pathsToScopes[path] :
        _this;

      const doValidateOptions = {
        skipSchemaValidators: skipSchemaValidators[path],
        path: path
      };
      schemaType.doValidate(val, function(err) {
        if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
          if (schemaType.$isSingleNested &&
              err instanceof ValidationError &&
              schemaType.schema.options.storeSubdocValidationError === false) {
            return --total || complete();
          }
          _this.invalidate(path, err, undefined, true);
        }
        --total || complete();
      }, scope, doValidateOptions);
    });
  };

  const numPaths = paths.length;
  for (let i = 0; i < numPaths; ++i) {
    validatePath(paths[i]);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
    var _context = context || this;
    var args = Array.prototype.slice.call(arguments);
    _this.wrap(name, fn, _context, args, options);
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      process.nextTick(() => fn.apply(this, arguments));
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
    var _context = context || this;
    var args = Array.prototype.slice.call(arguments);
    _this.wrap(name, fn, _context, args, options);
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      process.nextTick(() => fn.apply(this, arguments));
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function syncWrapper() {
    kareem.execPreSync(name, this, arguments);

    var toReturn = fn.apply(this, arguments);

    kareem.execPostSync(name, this, [toReturn]);

    return toReturn;
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.toObject(internalToObjectOptions);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(index) {
  this.__index = index;

  if (get(this, '$__.validationError', null) != null) {
    const keys = Object.keys(this.$__.validationError.errors);
    for (const key of keys) {
      this.invalidate(key, this.$__.validationError.errors[key]);
    }
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  this.$__.activePaths.modify(path);
  if (!this.__parentArray) {
    return;
  }

  const pathToCheck = this.__parentArray.$path() + '.0.' + path;
  if (this.isNew && this.ownerDocument().$__isSelected(pathToCheck)) {
    // Mark the WHOLE parent array as modified
    // if this is a new document (i.e., we are initializing
    // a document),
    this.__parentArray._markModified();
  } else {
    this.__parentArray._markModified(this, path);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  throw new Error('Mongoose does not support calling populate() on nested ' +
    'docs. Instead of `doc.arr[0].populate("path")`, use ' +
    '`doc.populate("arr.0.path")`');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = {};
  }
  options = options || {};

  if (!options.suppressWarning) {
    console.warn('mongoose: calling `save()` on a subdoc does **not** save ' +
      'the document to MongoDB, it only runs save middleware. ' +
      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +
      'if you\'re sure this behavior is right for your app.');
  }

  return promiseOrCallback(fn, cb => {
    this.$__save(cb);
  });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, fn) {
  if (typeof options === 'function' && !fn) {
    fn = options;
    options = undefined;
  }
  if (!this.__parentArray || (options && options.noop)) {
    this.$__remove(fn);
    return this;
  }

  let _id;
  if (!this.willRemove) {
    _id = this._doc._id;
    if (!_id) {
      throw new Error('For your own good, Mongoose does not know ' +
          'how to remove an EmbeddedDocument that has no _id');
    }
    this.__parentArray.pull({ _id: _id });
    this.willRemove = true;
    registerRemoveListener(this);
  }

  this.$__remove(fn);

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  throw new Error('The #update method is not available on EmbeddedDocuments');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.toObject({
    transform: false,
    virtuals: false,
    flattenDecimals: false
  });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, err, val) {
  Document.prototype.invalidate.call(this, path, err, val);

  if (!this[documentArrayParent] || this.__index == null) {
    if (err[validatorErrorSymbol] || err instanceof ValidationError) {
      return this.ownerDocument().$__.validationError;
    }
    throw err;
  }

  const index = this.__index;
  const parentPath = this.__parentArray.$path();
  const fullPath = [parentPath, index, path].join('.');
  this[documentArrayParent].invalidate(fullPath, err, val);

  return this.ownerDocument().$__.validationError;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (!this[documentArrayParent]) {
    return;
  }

  const index = this.__index;
  if (typeof index !== 'undefined') {
    const parentPath = this.__parentArray.$path();
    const fullPath = [parentPath, index, path].join('.');
    this[documentArrayParent].$markValid(fullPath);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  Document.prototype.$ignore.call(this, path);

  if (!this[documentArrayParent]) {
    return;
  }

  const index = this.__index;
  if (typeof index !== 'undefined') {
    const parentPath = this.__parentArray.$path();
    const fullPath = [parentPath, index, path].join('.');
    this[documentArrayParent].$ignore(fullPath);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const index = this.__index;
  if (typeof index !== 'undefined' && this[documentArrayParent]) {
    return !this[documentArrayParent].$__.validationError ||
      !this[documentArrayParent].$__.validationError.errors[this.$__fullPath(path)];
  }

  return true;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  if (this.$__.ownerDocument) {
    return this.$__.ownerDocument;
  }

  let parent = this[documentArrayParent];
  if (!parent) {
    return this;
  }

  while (parent[documentArrayParent] || parent.$__parent) {
    parent = parent[documentArrayParent] || parent.$__parent;
  }

  this.$__.ownerDocument = parent;
  return this.$__.ownerDocument;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (!this.$__.fullPath) {
    let parent = this; // eslint-disable-line consistent-this
    if (!parent[documentArrayParent]) {
      return path;
    }

    const paths = [];
    while (parent[documentArrayParent] || parent.$__parent) {
      if (parent[documentArrayParent]) {
        paths.unshift(parent.__parentArray.$path());
      } else {
        paths.unshift(parent.$basePath);
      }
      parent = parent[documentArrayParent] || parent.$__parent;
    }

    this.$__.fullPath = paths.join('.');

    if (!this.$__.ownerDocument) {
      // optimization
      this.$__.ownerDocument = parent;
    }
  }

  return path
    ? this.$__.fullPath + '.' + path
    : this.$__.fullPath;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this[documentArrayParent];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this[documentArrayParent];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.__parentArray;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(obj, fields, skipId, exclude, hasIncludedChildren) {
  const doc = {};

  const paths = Object.keys(this.schema.paths).
    // Don't build up any paths that are underneath a map, we don't know
    // what the keys will be
    filter(p => !p.includes('$*'));
  const plen = paths.length;
  let ii = 0;

  for (; ii < plen; ++ii) {
    const p = paths[ii];

    if (p === '_id') {
      if (skipId) {
        continue;
      }
      if (obj && '_id' in obj) {
        continue;
      }
    }

    const path = p.split('.');
    const len = path.length;
    const last = len - 1;
    let curPath = '';
    let doc_ = doc;
    let included = false;

    for (let i = 0; i < len; ++i) {
      const piece = path[i];

      curPath += (!curPath.length ? '' : '.') + piece;

      // support excluding intermediary levels
      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }

      if (i < last) {
        doc_ = doc_[piece] || (doc_[piece] = {});
      }
    }
  }

  this._doc = doc;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(doc, opts, fn) {
  if (typeof opts === 'function') {
    fn = opts;
    opts = null;
  }

  this.$__init(doc, opts);

  if (fn) {
    fn(null, this);
  }

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function updateOne(doc, options, callback) {
  const query = this.constructor.updateOne({ _id: this._id }, doc, options);
  query._pre(cb => {
    this.constructor._middleware.execPre('updateOne', this, [this], cb);
  });
  query._post(cb => {
    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);
  });

  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }

  if (callback != null) {
    return query.exec(callback);
  }

  return query;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function replaceOne() {
  const args = utils.args(arguments);
  args.unshift({ _id: this._id });
  return this.constructor.replaceOne.apply(this.constructor, args);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $session(session) {
  if (arguments.length === 0) {
    return this.$__.session;
  }
  this.$__.session = session;

  if (!this.ownerDocument) {
    const subdocs = this.$__getAllSubdocs();
    for (const child of subdocs) {
      child.$session(session);
    }
  }

  return session;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function overwrite(obj) {
  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));

  for (const key of keys) {
    if (key === '_id') {
      continue;
    }
    // Explicitly skip version key
    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {
      continue;
    }
    if (this.schema.options.discriminatorKey && key === this.schema.options.discriminatorKey) {
      continue;
    }
    this.$set(key, obj[key]);
  }

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $set(path, val, type, options) {

  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }

  if (path == null) {
    const _ = path;
    path = val;
    val = _;
  } else if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path instanceof Document) {
      if (path.$__isNested) {
        path = path.toObject();
      } else {
        path = path._doc;
      }
    }
    if (path == null) {
      const _ = path;
      path = val;
      val = _;
    }

    prefix = val ? val + '.' : '';
    keys = Object.keys(path);
    const len = keys.length;

    // `_skipMinimizeTopLevel` is because we may have deleted the top-level
    // nested key to ensure key order.
    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);
    if (len === 0 && _skipMinimizeTopLevel) {
      delete options._skipMinimizeTopLevel;
      if (val) {
        this.$set(val, {});
      }
      return this;
    }

    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix + key;
      pathtype = this.schema.pathType(pathName);

      // On initial set, delete any nested keys if we're going to overwrite
      // them to ensure we keep the user's key order.
      if (type === true &&
          !prefix &&
          path[key] != null &&
          pathtype === 'nested' &&
          this._doc[key] != null &&
          Object.keys(this._doc[key]).length === 0) {
        delete this._doc[key];
        // Make sure we set `{}` back even if we minimize re: gh-8565
        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
      }

      const someCondition = typeof path[key] === 'object' &&
                            !utils.isNativeObject(path[key]) &&
                            !utils.isMongooseType(path[key]) &&
                            path[key] != null &&
                            pathtype !== 'virtual' &&
                            pathtype !== 'real' &&
                            pathtype !== 'adhocOrUndefined' &&
                            !(this.$__path(pathName) instanceof MixedSchema) &&
                            !(this.schema.paths[pathName] &&
                            this.schema.paths[pathName].options &&
                            this.schema.paths[pathName].options.ref);

      if (someCondition) {
        this.$__.$setCalled.add(prefix + key);
        this.$set(path[key], prefix + key, constructing, options);
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && path[key] === void 0 &&
            this.get(pathName) !== void 0) {
          continue;
        }

        if (pathtype === 'adhocOrUndefined') {
          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
        }

        if (pathtype === 'real' || pathtype === 'virtual') {
          // Check for setting single embedded schema to document (gh-3535)
          let p = path[key];
          if (this.schema.paths[pathName] &&
              this.schema.paths[pathName].$isSingleNested &&
              path[key] instanceof Document) {
            p = p.toObject({ virtuals: false, transform: false });
          }
          this.$set(prefix + key, p, constructing, options);
        } else if (pathtype === 'nested' && path[key] instanceof Document) {
          this.$set(prefix + key,
            path[key].toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, path[key]);
          } else {
            throw new StrictModeError(key);
          }
        }
      } else if (path[key] !== void 0) {
        this.$set(prefix + key, path[key], constructing, options);
      }
    }

    return this;
  } else {
    this.$__.$setCalled.add(path);
  }

  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
  val = handleSpreadDoc(val);

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const priorVal = this.$__getValue(path);
        this.$__.savedState[path] = priorVal;

        const keys = Object.keys(priorVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = priorVal[key];
        }
      }

      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }

      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {
        this.unmarkModified(path);
      } else {
        this.markModified(path);
      }
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.$__isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) { pathtomark="path;" } else for (i="0;" i < parts.length; ++i) const subpath="parts.slice(0," + 1).join('.'); if (this.get(subpath, null, getters: false })="==" null) break; (!pathtomark) this doc is being constructed we should not trigger getters priorval="(()" => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }

  // If overwriting a subdocument path, make sure to clear out
  // any errors _before_ setting, so new errors that happen
  // get persisted. Re: #9080
  if (schema.$isSingleNested || schema.$isMongooseArray) {
    _markValidSubpaths(this, path);
  }

  if (schema.$isSingleNested && val != null && merge) {
    if (val instanceof Document) {
      val = val.toObject({ virtuals: false, transform: false });
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      this.$set(path + '.' + key, val[key], constructing, options);
    }

    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      return modelName === model.modelName || modelName === model.baseModelName;
    })();

    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = true;
      didPopulate = true;
    }

    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      for (const doc of val) {
        doc.$__.wasPopulated = true;
      }
      didPopulate = true;
    }

    if (this.schema.singleNestedPaths[path] == null) {
      // If this path is underneath a single nested schema, we'll call the setter
      // later in `$__set()` because we don't take `_doc` when we iterate through
      // a single nested doc. That's to make sure we get the correct context.
      // Otherwise we would double-call the setter, see gh-7196.
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (schema.$isMongooseDocumentArray &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] != null &&
        val[0].$__ != null &&
        val[0].$__.populated != null) {
      const populatedPaths = Object.keys(val[0].$__.populated);
      for (const populatedPath of populatedPaths) {
        this.populated(path + '.' + populatedPath,
          val.map(v => v.populated(populatedPath)),
          val[0].$__.populated[populatedPath].options);
      }
      didPopulate = true;
    }

    if (!didPopulate && this.$__.populated) {
      // If this array partially contains populated documents, convert them
      // all to ObjectIds re: #8443
      if (Array.isArray(val) && this.$__.populated[path]) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] instanceof Document) {
            val[i] = val[i]._id;
          }
        }
      }
      delete this.$__.populated[path];
    }

    if (schema.$isSingleNested && val != null) {
      _checkImmutableSubpaths(val, schema, priorVal);
    }

    this.$markValid(path);
  } catch (e) {
    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
      this.invalidate(path, e);
    } else if (e instanceof MongooseError.CastError) {
      this.invalidate(e.path, e);
      if (e.$originalErrorPath) {
        this.invalidate(path,
          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
      }
    } else {
      this.invalidate(path,
        new MongooseError.CastError(schema.instance, val, path, e));
    }
    shouldSet = false;
  }

  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);

    if (this.$__.savedState != null) {
      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        this.$__.savedState[path] = priorVal;
      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {
        this.unmarkModified(path);
      }
    }
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
}
                                              </=></td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $set(path, val, type, options) {

  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }

  if (path == null) {
    const _ = path;
    path = val;
    val = _;
  } else if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path instanceof Document) {
      if (path.$__isNested) {
        path = path.toObject();
      } else {
        path = path._doc;
      }
    }
    if (path == null) {
      const _ = path;
      path = val;
      val = _;
    }

    prefix = val ? val + '.' : '';
    keys = Object.keys(path);
    const len = keys.length;

    // `_skipMinimizeTopLevel` is because we may have deleted the top-level
    // nested key to ensure key order.
    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);
    if (len === 0 && _skipMinimizeTopLevel) {
      delete options._skipMinimizeTopLevel;
      if (val) {
        this.$set(val, {});
      }
      return this;
    }

    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix + key;
      pathtype = this.schema.pathType(pathName);

      // On initial set, delete any nested keys if we're going to overwrite
      // them to ensure we keep the user's key order.
      if (type === true &&
          !prefix &&
          path[key] != null &&
          pathtype === 'nested' &&
          this._doc[key] != null &&
          Object.keys(this._doc[key]).length === 0) {
        delete this._doc[key];
        // Make sure we set `{}` back even if we minimize re: gh-8565
        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
      }

      const someCondition = typeof path[key] === 'object' &&
                            !utils.isNativeObject(path[key]) &&
                            !utils.isMongooseType(path[key]) &&
                            path[key] != null &&
                            pathtype !== 'virtual' &&
                            pathtype !== 'real' &&
                            pathtype !== 'adhocOrUndefined' &&
                            !(this.$__path(pathName) instanceof MixedSchema) &&
                            !(this.schema.paths[pathName] &&
                            this.schema.paths[pathName].options &&
                            this.schema.paths[pathName].options.ref);

      if (someCondition) {
        this.$__.$setCalled.add(prefix + key);
        this.$set(path[key], prefix + key, constructing, options);
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && path[key] === void 0 &&
            this.get(pathName) !== void 0) {
          continue;
        }

        if (pathtype === 'adhocOrUndefined') {
          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
        }

        if (pathtype === 'real' || pathtype === 'virtual') {
          // Check for setting single embedded schema to document (gh-3535)
          let p = path[key];
          if (this.schema.paths[pathName] &&
              this.schema.paths[pathName].$isSingleNested &&
              path[key] instanceof Document) {
            p = p.toObject({ virtuals: false, transform: false });
          }
          this.$set(prefix + key, p, constructing, options);
        } else if (pathtype === 'nested' && path[key] instanceof Document) {
          this.$set(prefix + key,
            path[key].toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, path[key]);
          } else {
            throw new StrictModeError(key);
          }
        }
      } else if (path[key] !== void 0) {
        this.$set(prefix + key, path[key], constructing, options);
      }
    }

    return this;
  } else {
    this.$__.$setCalled.add(path);
  }

  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
  val = handleSpreadDoc(val);

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const priorVal = this.$__getValue(path);
        this.$__.savedState[path] = priorVal;

        const keys = Object.keys(priorVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = priorVal[key];
        }
      }

      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }

      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {
        this.unmarkModified(path);
      } else {
        this.markModified(path);
      }
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.$__isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) { pathtomark="path;" } else for (i="0;" i < parts.length; ++i) const subpath="parts.slice(0," + 1).join('.'); if (this.get(subpath, null, getters: false })="==" null) break; (!pathtomark) this doc is being constructed we should not trigger getters priorval="(()" => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }

  // If overwriting a subdocument path, make sure to clear out
  // any errors _before_ setting, so new errors that happen
  // get persisted. Re: #9080
  if (schema.$isSingleNested || schema.$isMongooseArray) {
    _markValidSubpaths(this, path);
  }

  if (schema.$isSingleNested && val != null && merge) {
    if (val instanceof Document) {
      val = val.toObject({ virtuals: false, transform: false });
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      this.$set(path + '.' + key, val[key], constructing, options);
    }

    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      return modelName === model.modelName || modelName === model.baseModelName;
    })();

    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = true;
      didPopulate = true;
    }

    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      for (const doc of val) {
        doc.$__.wasPopulated = true;
      }
      didPopulate = true;
    }

    if (this.schema.singleNestedPaths[path] == null) {
      // If this path is underneath a single nested schema, we'll call the setter
      // later in `$__set()` because we don't take `_doc` when we iterate through
      // a single nested doc. That's to make sure we get the correct context.
      // Otherwise we would double-call the setter, see gh-7196.
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (schema.$isMongooseDocumentArray &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] != null &&
        val[0].$__ != null &&
        val[0].$__.populated != null) {
      const populatedPaths = Object.keys(val[0].$__.populated);
      for (const populatedPath of populatedPaths) {
        this.populated(path + '.' + populatedPath,
          val.map(v => v.populated(populatedPath)),
          val[0].$__.populated[populatedPath].options);
      }
      didPopulate = true;
    }

    if (!didPopulate && this.$__.populated) {
      // If this array partially contains populated documents, convert them
      // all to ObjectIds re: #8443
      if (Array.isArray(val) && this.$__.populated[path]) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] instanceof Document) {
            val[i] = val[i]._id;
          }
        }
      }
      delete this.$__.populated[path];
    }

    if (schema.$isSingleNested && val != null) {
      _checkImmutableSubpaths(val, schema, priorVal);
    }

    this.$markValid(path);
  } catch (e) {
    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
      this.invalidate(path, e);
    } else if (e instanceof MongooseError.CastError) {
      this.invalidate(e.path, e);
      if (e.$originalErrorPath) {
        this.invalidate(path,
          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
      }
    } else {
      this.invalidate(path,
        new MongooseError.CastError(schema.instance, val, path, e));
    }
    shouldSet = false;
  }

  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);

    if (this.$__.savedState != null) {
      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        this.$__.savedState[path] = priorVal;
      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {
        this.unmarkModified(path);
      }
    }
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
}
                                              </=></td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  if (this.isNew) {
    return true;
  }

  // Re: the note about gh-7196, `val` is the raw value without casting or
  // setters if the full path is under a single nested subdoc because we don't
  // want to double run setters. So don't set it as modified. See gh-7264.
  if (this.schema.singleNestedPaths[path] != null) {
    return false;
  }

  if (val === void 0 && !this.$__isSelected(path)) {
    // when a path is not selected in a query, its initial
    // value will be undefined.
    return true;
  }

  if (val === void 0 && path in this.$__.activePaths.states.default) {
    // we're just unsetting the default value which was never saved
    return false;
  }

  // gh-3992: if setting a populated field to a doc, don't mark modified
  // if they have the same _id
  if (this.populated(path) &&
      val instanceof Document &&
      deepEqual(val._id, priorVal)) {
    return false;
  }

  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {
    return true;
  }

  if (!constructing &&
      val !== null &&
      val !== undefined &&
      path in this.$__.activePaths.states.default &&
      deepEqual(val, schema.getDefault(this, constructing))) {
    // a path with a default was $unset on the server
    // and the user is setting it to the same value again
    return true;
  }
  return false;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  Embedded = Embedded || require('./types/embedded');

  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
    schema, val, priorVal);
  const _this = this;

  if (shouldModify) {
    this.markModified(pathToMark);

    // handle directly setting arrays (gh-1126)
    MongooseArray || (MongooseArray = require('./types/array'));
    if (val && val.isMongooseArray) {
      val._registerAtomic('$set', val);

      // Update embedded document parent references (gh-5189)
      if (val.isMongooseDocumentArray) {
        val.forEach(function(item) {
          item && item.__parentArray && (item.__parentArray = val);
        });
      }

      // Small hack for gh-1638: if we're overwriting the entire array, ignore
      // paths that were modified before the array overwrite
      this.$__.activePaths.forEach(function(modifiedPath) {
        if (modifiedPath.startsWith(path + '.')) {
          _this.$__.activePaths.ignore(modifiedPath);
        }
      });
    }
  }

  let obj = this._doc;
  let i = 0;
  const l = parts.length;
  let cur = '';

  for (; i < l; i++) {
    const next = i + 1;
    const last = next === l;
    cur += (cur ? '.' + parts[i] : parts[i]);
    if (specialProperties.has(parts[i])) {
      return;
    }

    if (last) {
      if (obj instanceof Map) {
        obj.set(parts[i], val);
      } else {
        obj[parts[i]] = val;
      }
    } else {
      if (utils.isPOJO(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else {
        obj[parts[i]] = obj[parts[i]] || {};
        obj = obj[parts[i]];
      }
    }
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  return utils.getValue(path, this._doc);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, val) {
  utils.setValue(path, val, this._doc);
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, type, options) {
  let adhoc;
  options = options || {};
  if (type) {
    adhoc = this.schema.interpretAsType(path, type, this.schema.options);
  }

  let schema = this.$__path(path);
  if (schema == null) {
    schema = this.schema.virtualpath(path);
  }
  if (schema instanceof MixedSchema) {
    const virtual = this.schema.virtualpath(path);
    if (virtual != null) {
      schema = virtual;
    }
  }
  const pieces = path.split('.');
  let obj = this._doc;

  if (schema instanceof VirtualType) {
    return schema.applyGetters(void 0, this);
  }

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[pieces[0]] == 'string') {
    pieces[0] = this.schema.aliases[pieces[0]];
  }

  for (let i = 0, l = pieces.length; i < l; i++) {
    if (obj && obj._doc) {
      obj = obj._doc;
    }

    if (obj == null) {
      obj = void 0;
    } else if (obj instanceof Map) {
      obj = obj.get(pieces[i], { getters: false });
    } else if (i === l - 1) {
      obj = utils.getValue(pieces[i], obj);
    } else {
      obj = obj[pieces[i]];
    }
  }

  if (adhoc) {
    obj = adhoc.cast(obj);
  }

  if (schema != null && options.getters !== false) {
    obj = schema.applyGetters(obj, this);
  } else if (this.schema.nested[path] && options.virtuals) {
    // Might need to apply virtuals if this is a nested path
    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });
  }

  return obj;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const adhocs = this.$__.adhocPaths;
  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;

  if (adhocType) {
    return adhocType;
  }
  return this.schema.path(path);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  this.$__.activePaths.init(path);
  delete this.$__.pathsToScopes[path];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return Object.keys(this.$__.activePaths.states.modify);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const isEmptyOptions = {
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  };

  if (arguments.length > 0) {
    const v = this.get(path);
    if (v == null) {
      return true;
    }
    if (typeof v !== 'object') {
      return false;
    }
    if (utils.isPOJO(v)) {
      return _isEmpty(v);
    }
    return Object.keys(v.toObject(isEmptyOptions)).length === 0;
  }

  return Object.keys(this.toObject(isEmptyOptions)).length === 0;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  options = options || {};
  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  const _this = this;
  return directModifiedPaths.reduce(function(list, path) {
    const parts = path.split('.');
    list = list.concat(parts.reduce(function(chains, part, i) {
      return chains.concat(parts.slice(0, i).concat(part).join('.'));
    }, []).filter(function(chain) {
      return (list.indexOf(chain) === -1);
    }));

    if (!options.includeChildren) {
      return list;
    }

    let cur = _this.get(path);
    if (cur != null && typeof cur === 'object') {
      if (cur._doc) {
        cur = cur._doc;
      }
      if (Array.isArray(cur)) {
        const len = cur.length;
        for (let i = 0; i < len; ++i) {
          if (list.indexOf(path + '.' + i) === -1) {
            list.push(path + '.' + i);
            if (cur[i] != null && cur[i].$__) {
              const modified = cur[i].modifiedPaths();
              for (const childPath of modified) {
                list.push(path + '.' + i + '.' + childPath);
              }
            }
          }
        }
      } else {
        Object.keys(cur).
          filter(function(key) {
            return list.indexOf(path + '.' + key) === -1;
          }).
          forEach(function(key) {
            list.push(path + '.' + key);
          });
      }
    }

    return list;
  }, []);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(paths, modifiedPaths) {
  if (paths) {
    if (!Array.isArray(paths)) {
      paths = paths.split(' ');
    }
    const modified = modifiedPaths || this[documentModifiedPaths]();
    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
    const isModifiedChild = paths.some(function(path) {
      return !!~modified.indexOf(path);
    });

    return isModifiedChild || paths.some(function(path) {
      return directModifiedPaths.some(function(mod) {
        return mod === path || path.startsWith(mod + '.');
      });
    });
  }

  return this.$__.activePaths.some('modify');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('default');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.default.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(val) {
  if (arguments.length === 0) {
    return !!this.$__.isDeleted;
  }

  this.$__.isDeleted = !!val;
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('modify');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.modify.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('init');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.init.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__isSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (path in this.$__.selected) {
    return inclusive;
  }

  const pathDot = path + '.';

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }

    if (cur.startsWith(pathDot)) {
      return inclusive || cur !== pathDot;
    }

    if (pathDot.startsWith(cur + '.')) {
      return inclusive;
    }
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__isSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (path in this.$__.selected) {
    return inclusive;
  }

  const pathDot = path + '.';

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }

    if (cur.startsWith(pathDot)) {
      return inclusive || cur !== pathDot;
    }

    if (pathDot.startsWith(cur + '.')) {
      return inclusive;
    }
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isDirectSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.isDirectSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (this.$__.selected.hasOwnProperty(path)) {
    return inclusive;
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options, callback) {
  let parallelValidate;
  this.$op = 'validate';

  if (this.ownerDocument != null) {
    // Skip parallel validate check for subdocuments
  } else if (this.$__.validating) {
    parallelValidate = new ParallelValidateError(this, {
      parentStack: options && options.parentStack,
      conflictStack: this.$__.validating.stack
    });
  } else {
    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
  }

  if (typeof pathsToValidate === 'function') {
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = pathsToValidate;
    pathsToValidate = null;
  }

  return promiseOrCallback(callback, cb => {
    if (parallelValidate != null) {
      return cb(parallelValidate);
    }

    this.$__validate(pathsToValidate, options, (error) => {
      this.$op = null;
      cb(error);
    });
  }, this.constructor.events);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options) {
  const _this = this;

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }

  if (typeof pathsToValidate === 'string') {
    pathsToValidate = pathsToValidate.split(' ');
  }

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];

  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  }
  const validating = {};

  paths.forEach(function(path) {
    if (validating[path]) {
      return;
    }

    validating[path] = true;

    const p = _this.schema.path(path);
    if (!p) {
      return;
    }
    if (!_this.$isValid(path)) {
      return;
    }

    const val = _this.$__getValue(path);
    const err = p.doValidateSync(val, _this, {
      skipSchemaValidators: skipSchemaValidators[path],
      path: path
    });
    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
      if (p.$isSingleNested &&
          err instanceof ValidationError &&
          p.schema.options.storeSubdocValidationError === false) {
        return;
      }
      _this.invalidate(path, err, undefined, true);
    }
  });

  const err = _this.$__.validationError;
  _this.$__.validationError = undefined;
  _this.emit('validate', _this);
  _this.constructor.emit('validate', _this);

  if (err) {
    for (const key in err.errors) {
      // Make sure cast errors persist
      if (err.errors[key] instanceof MongooseError.CastError) {
        _this.invalidate(key, err.errors[key]);
      }
    }
  }

  return err;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function reset() {
  let _this = this;
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  this.$__.activePaths
    .map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    })
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    })
    .forEach(function(array) {
      let i = array.length;
      while (i--) {
        const doc = array[i];
        if (!doc) {
          continue;
        }
        doc.$__reset();
      }

      _this.$__.activePaths.init(array.$path());

      array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
      array[arrayAtomicsSymbol] = {};
    });

  this.$__.activePaths.
    map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    }).
    filter(function(val) {
      return val && val.$isSingleNested;
    }).
    forEach(function(doc) {
      doc.$__reset();
      _this.$__.activePaths.init(doc.$basePath);
    });

  // clear atomics
  this.$__dirty().forEach(function(dirt) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol]) {
      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
      type[arrayAtomicsSymbol] = {};
    }
  });

  this.$__.backup = {};
  this.$__.backup.activePaths = {
    modify: Object.assign({}, this.$__.activePaths.states.modify),
    default: Object.assign({}, this.$__.activePaths.states.default)
  };
  this.$__.backup.validationError = this.$__.validationError;
  this.$__.backup.errors = this.errors;

  // Clear 'dirty' cache
  this.$__.activePaths.clear('modify');
  this.$__.activePaths.clear('default');
  this.$__.validationError = undefined;
  this.errors = undefined;
  _this = this;
  this.schema.requiredPaths().forEach(function(path) {
    _this.$__.activePaths.require(path);
  });

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $__undoReset() {
  if (this.$__.backup == null || this.$__.backup.activePaths == null) {
    return;
  }

  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;

  this.$__.validationError = this.$__.backup.validationError;
  this.errors = this.$__.backup.errors;

  for (const dirt of this.$__dirty()) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
    }
  }

  for (const subdoc of this.$__getAllSubdocs()) {
    subdoc.$__undoReset();
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const _this = this;

  let all = this.$__.activePaths.map('modify', function(path) {
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  });

  // gh-2558: if we had to set a default and the value is not undefined,
  // we have to save as well
  all = all.concat(this.$__.activePaths.map('default', function(path) {
    if (path === '_id' || _this.$__getValue(path) == null) {
      return;
    }
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  }));

  // Sort dirty paths in a flat hierarchy.
  all.sort(function(a, b) {
    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
  });

  // Ignore "foo.a" if "foo" is dirty already.
  const minimal = [];
  let lastPath;
  let top;

  all.forEach(function(item) {
    if (!item) {
      return;
    }
    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {
      lastPath = item.path + '.';
      minimal.push(item);
      top = item;
    } else if (top != null &&
        top.value != null &&
        top.value[arrayAtomicsSymbol] != null &&
        top.value.hasAtomics()) {
      // special case for top level MongooseArrays
      // the `top` array itself and a sub path of `top` are being modified.
      // the only way to honor all of both modifications is through a $set
      // of entire array.
      top.value[arrayAtomicsSymbol] = {};
      top.value[arrayAtomicsSymbol].$set = top.value;
    }
  });

  top = lastPath = null;
  return minimal;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(schema) {
  schema.plugin(idGetter, { deduplicate: true });
  compile(schema.tree, this, undefined, schema.options);

  // Apply default getters if virtual doesn't have any (gh-6262)
  for (const key of Object.keys(schema.virtuals)) {
    schema.virtuals[key]._applyDefaultGetters();
  }

  this.schema = schema;
  this[documentSchemaSymbol] = schema;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  // validate all document arrays.
  return this.$__.activePaths
    .map('init', 'modify', function(i) {
      return this.$__getValue(i);
    }.bind(this))
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    }).reduce(function(seed, array) {
      return seed.concat(array);
    }, [])
    .filter(function(doc) {
      return doc;
    });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));
  Embedded = Embedded || require('./types/embedded');

  function docReducer(doc, seed, path) {
    let val = doc;
    if (path) {
      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
        val = doc._doc[path];
      } else {
        val = doc[path];
      }
    }
    if (val instanceof Embedded) {
      seed.push(val);
    } else if (val instanceof Map) {
      seed = Array.from(val.keys()).reduce(function(seed, path) {
        return docReducer(val.get(path), seed, null);
      }, seed);
    } else if (val && val.$isSingleNested) {
      seed = Object.keys(val._doc).reduce(function(seed, path) {
        return docReducer(val._doc, seed, path);
      }, seed);
      seed.push(val);
    } else if (val && val.isMongooseDocumentArray) {
      val.forEach(function _docReduce(doc) {
        if (!doc || !doc._doc) {
          return;
        }
        seed = Object.keys(doc._doc).reduce(function(seed, path) {
          return docReducer(doc._doc, seed, path);
        }, seed);
        if (doc instanceof Embedded) {
          seed.push(doc);
        }
      });
    } else if (val instanceof Document && val.$__isNested) {
      seed = Object.keys(val).reduce(function(seed, path) {
        return docReducer(val, seed, path);
      }, seed);
    }
    return seed;
  }

  const _this = this;
  const subDocs = Object.keys(this._doc).reduce(function(seed, path) {
    return docReducer(_this, seed, path);
  }, []);

  return subDocs;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function handleReject(err) {
  // emit on the Model if listening
  if (this.listeners('error').length) {
    this.emit('error', err);
  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {
    this.constructor.emit('error', err);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, json) {
  let defaultOptions = {
    transform: true,
    flattenDecimals: true
  };

  const path = json ? 'toJSON' : 'toObject';
  const baseOptions = get(this, 'constructor.base.options.' + path, {});
  const schemaOptions = get(this, 'schema.options', {});
  // merge base default options with Schema's set default options if available.
  // `clone` is necessary here because `utils.options` directly modifies the second input.
  defaultOptions = utils.options(defaultOptions, clone(baseOptions));
  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));

  // If options do not exist or is not an object, set it to empty object
  options = utils.isPOJO(options) ? clone(options) : {};
  options._calledWithOptions = options._calledWithOptions || clone(options);

  if (!('flattenMaps' in options)) {
    options.flattenMaps = defaultOptions.flattenMaps;
  }

  let _minimize;
  if (options._calledWithOptions.minimize != null) {
    _minimize = options.minimize;
  } else if (defaultOptions.minimize != null) {
    _minimize = defaultOptions.minimize;
  } else {
    _minimize = schemaOptions.minimize;
  }

  // The original options that will be passed to `clone()`. Important because
  // `clone()` will recursively call `$toObject()` on embedded docs, so we
  // need the original options the user passed in, plus `_isNested` and
  // `_parentOptions` for checking whether we need to depopulate.
  const cloneOptions = Object.assign(utils.clone(options), {
    _isNested: true,
    json: json,
    minimize: _minimize
  });

  if (utils.hasUserDefinedProperty(options, 'getters')) {
    cloneOptions.getters = options.getters;
  }
  if (utils.hasUserDefinedProperty(options, 'virtuals')) {
    cloneOptions.virtuals = options.virtuals;
  }

  const depopulate = options.depopulate ||
    get(options, '_parentOptions.depopulate', false);
  // _isNested will only be true if this is not the top level document, we
  // should never depopulate
  if (depopulate && options._isNested && this.$__.wasPopulated) {
    // populated paths that we set to a document
    return clone(this._id, cloneOptions);
  }

  // merge default options with input options.
  options = utils.options(defaultOptions, options);
  options._isNested = true;
  options.json = json;
  options.minimize = _minimize;

  cloneOptions._parentOptions = options;
  cloneOptions._skipSingleNestedGetters = true;

  const gettersOptions = Object.assign({}, cloneOptions);
  gettersOptions._skipSingleNestedGetters = false;

  // remember the root transform function
  // to save it from being overwritten by sub-transform functions
  const originalTransform = options.transform;

  let ret = clone(this._doc, cloneOptions) || {};

  if (options.getters) {
    applyGetters(this, ret, gettersOptions);

    if (options.minimize) {
      ret = minimize(ret) || {};
    }
  }

  if (options.virtuals || (options.getters && options.virtuals !== false)) {
    applyVirtuals(this, ret, gettersOptions, options);
  }

  if (options.versionKey === false && this.schema.options.versionKey) {
    delete ret[this.schema.options.versionKey];
  }

  let transform = options.transform;

  // In the case where a subdocument has its own transform function, we need to
  // check and see if the parent has a transform (options.transform) and if the
  // child schema has a transform (this.schema.options.toObject) In this case,
  // we need to adjust options.transform to be the child schema's transform and
  // not the parent schema's
  if (transform) {
    applySchemaTypeTransforms(this, ret);
  }

  if (options.useProjection) {
    omitDeselectedFields(this, ret);
  }

  if (transform === true || (schemaOptions.toObject && transform)) {
    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;

    if (opts) {
      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
    }
  } else {
    options.transform = originalTransform;
  }

  if (typeof transform === 'function') {
    const xformed = transform(this, ret, options);
    if (typeof xformed !== 'undefined') {
      ret = xformed;
    }
  }

  return ret;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  return this.$toObject(options);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  return this.$toObject(options, true);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const ret = this.inspect();
  if (typeof ret === 'string') {
    return ret;
  }
  return inspect(ret);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(doc) {
  if (!doc) {
    return false;
  }

  const tid = this.$__getValue('_id');
  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;
  if (!tid && !docid) {
    return deepEqual(this, doc);
  }
  return tid && tid.equals
    ? tid.equals(docid)
    : tid === docid;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(callback) {
  const isUsingShorthand = callback != null && typeof callback !== 'function';
  if (isUsingShorthand) {
    return this.populate.apply(this, arguments).execPopulate();
  }

  return promiseOrCallback(callback, cb => {
    this.populate(cb);
  }, this.constructor.events);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, val, options) {
  // val and options are internal
  if (val === null || val === void 0) {
    if (!this.$__.populated) {
      return undefined;
    }
    const v = this.$__.populated[path];
    if (v) {
      return v.value;
    }
    return undefined;
  }

  // internal
  if (val === true) {
    if (!this.$__.populated) {
      return undefined;
    }
    return this.$__.populated[path];
  }

  this.$__.populated || (this.$__.populated = {});
  this.$__.populated[path] = { value: val, options: options };

  // If this was a nested populate, make sure each populated doc knows
  // about its populated children (gh-7685)
  const pieces = path.split('.');
  for (let i = 0; i < pieces.length - 1; ++i) {
    const subpath = pieces.slice(0, i + 1).join('.');
    const subdoc = this.get(subpath);
    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
      const rest = pieces.slice(i + 1).join('.');
      subdoc.populated(rest, val, options);
      // No need to continue because the above recursion should take care of
      // marking the rest of the docs as populated
      break;
    }
  }

  return val;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (typeof path === 'string') {
    path = path.split(' ');
  }

  let populatedIds;
  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
  const populated = get(this, '$__.populated', {});

  if (arguments.length === 0) {
    // Depopulate all
    for (const virtualKey of virtualKeys) {
      delete this.$$populatedVirtuals[virtualKey];
      delete this._doc[virtualKey];
      delete populated[virtualKey];
    }

    const keys = Object.keys(populated);

    for (const key of keys) {
      populatedIds = this.populated(key);
      if (!populatedIds) {
        continue;
      }
      delete populated[key];
      this.$set(key, populatedIds);
    }
    return this;
  }

  for (const singlePath of path) {
    populatedIds = this.populated(singlePath);
    delete populated[singlePath];

    if (virtualKeys.indexOf(singlePath) !== -1) {
      delete this.$$populatedVirtuals[singlePath];
      delete this._doc[singlePath];
    } else if (populatedIds) {
      this.$set(singlePath, populatedIds);
    }
  }
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const delta = this.$__delta();
  const changes = delta ? delta[1] : {};
  return changes;
}
                                              </td>
                                              
                                          </tr>
                                          
                                          <tr>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  {
  _id: 60735418b255ff0b80680324,
  questionId: 15,
  question: 'What is formal testing?',
  answer: 'Verification of software, according to the test plan, test procedures and relevant documentation, taking into account the wishes of the client',
  rightAnswer: false
},{
  _id: 60735418b255ff0b80680325,
  questionId: 8,
  question: "Agile's main ideas",
  answer: 'All options are incorrect',
  rightAnswer: false
},{
  _id: 60735418b255ff0b80680326,
  questionId: 22,
  question: 'This is a comprehensive user testing of concurrent access to an application to verify the impact on a code, module or database. Mainly detects deadlocks in code.',
  answer: 'Currency testing',
  rightAnswer: true
},{
  _id: 60735418b255ff0b80680327,
  questionId: 18,
  question: 'Which of the following is superfluous',
  answer: 'Check list',
  rightAnswer: false
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  1
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  true
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  false
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  8
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  Agile's main ideas
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  All options are incorrect
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  false
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  60735418b255ff0b80680325
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  60735418b255ff0b80680325
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function EmbeddedDocument() {
    Subdocument.apply(this, arguments);

    this.$session(this.ownerDocument().$session());
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  questions
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options, callback) {
  if (typeof pathsToValidate === 'function') {
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }

  const _this = this;
  const _complete = () => {
    let validationError = this.$__.validationError;
    this.$__.validationError = undefined;

    if (shouldValidateModifiedOnly && validationError != null) {
      // Remove any validation errors that aren't from modified paths
      const errors = Object.keys(validationError.errors);
      for (const errPath of errors) {
        if (!this.isModified(errPath)) {
          delete validationError.errors[errPath];
        }
      }
      if (Object.keys(validationError.errors).length === 0) {
        validationError = void 0;
      }
    }

    this.$__.cachedRequired = {};
    this.emit('validate', _this);
    this.constructor.emit('validate', _this);

    this.$__.validating = null;
    if (validationError) {
      for (const key in validationError.errors) {
        // Make sure cast errors persist
        if (!this[documentArrayParent] &&
            validationError.errors[key] instanceof MongooseError.CastError) {
          this.invalidate(key, validationError.errors[key]);
        }
      }

      return validationError;
    }
  };

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];
  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  }
  if (paths.length === 0) {
    return process.nextTick(function() {
      const error = _complete();
      if (error) {
        return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
          callback(error);
        });
      }
      callback(null, _this);
    });
  }

  const validated = {};
  let total = 0;

  const complete = function() {
    const error = _complete();
    if (error) {
      return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
        callback(error);
      });
    }
    callback(null, _this);
  };

  const validatePath = function(path) {
    if (path == null || validated[path]) {
      return;
    }

    validated[path] = true;
    total++;

    process.nextTick(function() {
      const schemaType = _this.schema.path(path);

      if (!schemaType) {
        return --total || complete();
      }

      // If user marked as invalid or there was a cast error, don't validate
      if (!_this.$isValid(path)) {
        --total || complete();
        return;
      }

      let val = _this.$__getValue(path);

      // If you `populate()` and get back a null value, required validators
      // shouldn't fail (gh-8018). We should always fall back to the populated
      // value.
      let pop;
      if (val == null && (pop = _this.populated(path))) {
        val = pop;
      }
      const scope = path in _this.$__.pathsToScopes ?
        _this.$__.pathsToScopes[path] :
        _this;

      const doValidateOptions = {
        skipSchemaValidators: skipSchemaValidators[path],
        path: path
      };
      schemaType.doValidate(val, function(err) {
        if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
          if (schemaType.$isSingleNested &&
              err instanceof ValidationError &&
              schemaType.schema.options.storeSubdocValidationError === false) {
            return --total || complete();
          }
          _this.invalidate(path, err, undefined, true);
        }
        --total || complete();
      }, scope, doValidateOptions);
    });
  };

  const numPaths = paths.length;
  for (let i = 0; i < numPaths; ++i) {
    validatePath(paths[i]);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
    var _context = context || this;
    var args = Array.prototype.slice.call(arguments);
    _this.wrap(name, fn, _context, args, options);
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      process.nextTick(() => fn.apply(this, arguments));
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
    var _context = context || this;
    var args = Array.prototype.slice.call(arguments);
    _this.wrap(name, fn, _context, args, options);
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      process.nextTick(() => fn.apply(this, arguments));
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function syncWrapper() {
    kareem.execPreSync(name, this, arguments);

    var toReturn = fn.apply(this, arguments);

    kareem.execPostSync(name, this, [toReturn]);

    return toReturn;
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.toObject(internalToObjectOptions);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(index) {
  this.__index = index;

  if (get(this, '$__.validationError', null) != null) {
    const keys = Object.keys(this.$__.validationError.errors);
    for (const key of keys) {
      this.invalidate(key, this.$__.validationError.errors[key]);
    }
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  this.$__.activePaths.modify(path);
  if (!this.__parentArray) {
    return;
  }

  const pathToCheck = this.__parentArray.$path() + '.0.' + path;
  if (this.isNew && this.ownerDocument().$__isSelected(pathToCheck)) {
    // Mark the WHOLE parent array as modified
    // if this is a new document (i.e., we are initializing
    // a document),
    this.__parentArray._markModified();
  } else {
    this.__parentArray._markModified(this, path);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  throw new Error('Mongoose does not support calling populate() on nested ' +
    'docs. Instead of `doc.arr[0].populate("path")`, use ' +
    '`doc.populate("arr.0.path")`');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = {};
  }
  options = options || {};

  if (!options.suppressWarning) {
    console.warn('mongoose: calling `save()` on a subdoc does **not** save ' +
      'the document to MongoDB, it only runs save middleware. ' +
      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +
      'if you\'re sure this behavior is right for your app.');
  }

  return promiseOrCallback(fn, cb => {
    this.$__save(cb);
  });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, fn) {
  if (typeof options === 'function' && !fn) {
    fn = options;
    options = undefined;
  }
  if (!this.__parentArray || (options && options.noop)) {
    this.$__remove(fn);
    return this;
  }

  let _id;
  if (!this.willRemove) {
    _id = this._doc._id;
    if (!_id) {
      throw new Error('For your own good, Mongoose does not know ' +
          'how to remove an EmbeddedDocument that has no _id');
    }
    this.__parentArray.pull({ _id: _id });
    this.willRemove = true;
    registerRemoveListener(this);
  }

  this.$__remove(fn);

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  throw new Error('The #update method is not available on EmbeddedDocuments');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.toObject({
    transform: false,
    virtuals: false,
    flattenDecimals: false
  });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, err, val) {
  Document.prototype.invalidate.call(this, path, err, val);

  if (!this[documentArrayParent] || this.__index == null) {
    if (err[validatorErrorSymbol] || err instanceof ValidationError) {
      return this.ownerDocument().$__.validationError;
    }
    throw err;
  }

  const index = this.__index;
  const parentPath = this.__parentArray.$path();
  const fullPath = [parentPath, index, path].join('.');
  this[documentArrayParent].invalidate(fullPath, err, val);

  return this.ownerDocument().$__.validationError;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (!this[documentArrayParent]) {
    return;
  }

  const index = this.__index;
  if (typeof index !== 'undefined') {
    const parentPath = this.__parentArray.$path();
    const fullPath = [parentPath, index, path].join('.');
    this[documentArrayParent].$markValid(fullPath);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  Document.prototype.$ignore.call(this, path);

  if (!this[documentArrayParent]) {
    return;
  }

  const index = this.__index;
  if (typeof index !== 'undefined') {
    const parentPath = this.__parentArray.$path();
    const fullPath = [parentPath, index, path].join('.');
    this[documentArrayParent].$ignore(fullPath);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const index = this.__index;
  if (typeof index !== 'undefined' && this[documentArrayParent]) {
    return !this[documentArrayParent].$__.validationError ||
      !this[documentArrayParent].$__.validationError.errors[this.$__fullPath(path)];
  }

  return true;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  if (this.$__.ownerDocument) {
    return this.$__.ownerDocument;
  }

  let parent = this[documentArrayParent];
  if (!parent) {
    return this;
  }

  while (parent[documentArrayParent] || parent.$__parent) {
    parent = parent[documentArrayParent] || parent.$__parent;
  }

  this.$__.ownerDocument = parent;
  return this.$__.ownerDocument;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (!this.$__.fullPath) {
    let parent = this; // eslint-disable-line consistent-this
    if (!parent[documentArrayParent]) {
      return path;
    }

    const paths = [];
    while (parent[documentArrayParent] || parent.$__parent) {
      if (parent[documentArrayParent]) {
        paths.unshift(parent.__parentArray.$path());
      } else {
        paths.unshift(parent.$basePath);
      }
      parent = parent[documentArrayParent] || parent.$__parent;
    }

    this.$__.fullPath = paths.join('.');

    if (!this.$__.ownerDocument) {
      // optimization
      this.$__.ownerDocument = parent;
    }
  }

  return path
    ? this.$__.fullPath + '.' + path
    : this.$__.fullPath;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this[documentArrayParent];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this[documentArrayParent];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.__parentArray;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(obj, fields, skipId, exclude, hasIncludedChildren) {
  const doc = {};

  const paths = Object.keys(this.schema.paths).
    // Don't build up any paths that are underneath a map, we don't know
    // what the keys will be
    filter(p => !p.includes('$*'));
  const plen = paths.length;
  let ii = 0;

  for (; ii < plen; ++ii) {
    const p = paths[ii];

    if (p === '_id') {
      if (skipId) {
        continue;
      }
      if (obj && '_id' in obj) {
        continue;
      }
    }

    const path = p.split('.');
    const len = path.length;
    const last = len - 1;
    let curPath = '';
    let doc_ = doc;
    let included = false;

    for (let i = 0; i < len; ++i) {
      const piece = path[i];

      curPath += (!curPath.length ? '' : '.') + piece;

      // support excluding intermediary levels
      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }

      if (i < last) {
        doc_ = doc_[piece] || (doc_[piece] = {});
      }
    }
  }

  this._doc = doc;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(doc, opts, fn) {
  if (typeof opts === 'function') {
    fn = opts;
    opts = null;
  }

  this.$__init(doc, opts);

  if (fn) {
    fn(null, this);
  }

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function updateOne(doc, options, callback) {
  const query = this.constructor.updateOne({ _id: this._id }, doc, options);
  query._pre(cb => {
    this.constructor._middleware.execPre('updateOne', this, [this], cb);
  });
  query._post(cb => {
    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);
  });

  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }

  if (callback != null) {
    return query.exec(callback);
  }

  return query;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function replaceOne() {
  const args = utils.args(arguments);
  args.unshift({ _id: this._id });
  return this.constructor.replaceOne.apply(this.constructor, args);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $session(session) {
  if (arguments.length === 0) {
    return this.$__.session;
  }
  this.$__.session = session;

  if (!this.ownerDocument) {
    const subdocs = this.$__getAllSubdocs();
    for (const child of subdocs) {
      child.$session(session);
    }
  }

  return session;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function overwrite(obj) {
  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));

  for (const key of keys) {
    if (key === '_id') {
      continue;
    }
    // Explicitly skip version key
    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {
      continue;
    }
    if (this.schema.options.discriminatorKey && key === this.schema.options.discriminatorKey) {
      continue;
    }
    this.$set(key, obj[key]);
  }

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $set(path, val, type, options) {

  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }

  if (path == null) {
    const _ = path;
    path = val;
    val = _;
  } else if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path instanceof Document) {
      if (path.$__isNested) {
        path = path.toObject();
      } else {
        path = path._doc;
      }
    }
    if (path == null) {
      const _ = path;
      path = val;
      val = _;
    }

    prefix = val ? val + '.' : '';
    keys = Object.keys(path);
    const len = keys.length;

    // `_skipMinimizeTopLevel` is because we may have deleted the top-level
    // nested key to ensure key order.
    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);
    if (len === 0 && _skipMinimizeTopLevel) {
      delete options._skipMinimizeTopLevel;
      if (val) {
        this.$set(val, {});
      }
      return this;
    }

    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix + key;
      pathtype = this.schema.pathType(pathName);

      // On initial set, delete any nested keys if we're going to overwrite
      // them to ensure we keep the user's key order.
      if (type === true &&
          !prefix &&
          path[key] != null &&
          pathtype === 'nested' &&
          this._doc[key] != null &&
          Object.keys(this._doc[key]).length === 0) {
        delete this._doc[key];
        // Make sure we set `{}` back even if we minimize re: gh-8565
        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
      }

      const someCondition = typeof path[key] === 'object' &&
                            !utils.isNativeObject(path[key]) &&
                            !utils.isMongooseType(path[key]) &&
                            path[key] != null &&
                            pathtype !== 'virtual' &&
                            pathtype !== 'real' &&
                            pathtype !== 'adhocOrUndefined' &&
                            !(this.$__path(pathName) instanceof MixedSchema) &&
                            !(this.schema.paths[pathName] &&
                            this.schema.paths[pathName].options &&
                            this.schema.paths[pathName].options.ref);

      if (someCondition) {
        this.$__.$setCalled.add(prefix + key);
        this.$set(path[key], prefix + key, constructing, options);
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && path[key] === void 0 &&
            this.get(pathName) !== void 0) {
          continue;
        }

        if (pathtype === 'adhocOrUndefined') {
          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
        }

        if (pathtype === 'real' || pathtype === 'virtual') {
          // Check for setting single embedded schema to document (gh-3535)
          let p = path[key];
          if (this.schema.paths[pathName] &&
              this.schema.paths[pathName].$isSingleNested &&
              path[key] instanceof Document) {
            p = p.toObject({ virtuals: false, transform: false });
          }
          this.$set(prefix + key, p, constructing, options);
        } else if (pathtype === 'nested' && path[key] instanceof Document) {
          this.$set(prefix + key,
            path[key].toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, path[key]);
          } else {
            throw new StrictModeError(key);
          }
        }
      } else if (path[key] !== void 0) {
        this.$set(prefix + key, path[key], constructing, options);
      }
    }

    return this;
  } else {
    this.$__.$setCalled.add(path);
  }

  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
  val = handleSpreadDoc(val);

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const priorVal = this.$__getValue(path);
        this.$__.savedState[path] = priorVal;

        const keys = Object.keys(priorVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = priorVal[key];
        }
      }

      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }

      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {
        this.unmarkModified(path);
      } else {
        this.markModified(path);
      }
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.$__isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) { pathtomark="path;" } else for (i="0;" i < parts.length; ++i) const subpath="parts.slice(0," + 1).join('.'); if (this.get(subpath, null, getters: false })="==" null) break; (!pathtomark) this doc is being constructed we should not trigger getters priorval="(()" => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }

  // If overwriting a subdocument path, make sure to clear out
  // any errors _before_ setting, so new errors that happen
  // get persisted. Re: #9080
  if (schema.$isSingleNested || schema.$isMongooseArray) {
    _markValidSubpaths(this, path);
  }

  if (schema.$isSingleNested && val != null && merge) {
    if (val instanceof Document) {
      val = val.toObject({ virtuals: false, transform: false });
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      this.$set(path + '.' + key, val[key], constructing, options);
    }

    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      return modelName === model.modelName || modelName === model.baseModelName;
    })();

    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = true;
      didPopulate = true;
    }

    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      for (const doc of val) {
        doc.$__.wasPopulated = true;
      }
      didPopulate = true;
    }

    if (this.schema.singleNestedPaths[path] == null) {
      // If this path is underneath a single nested schema, we'll call the setter
      // later in `$__set()` because we don't take `_doc` when we iterate through
      // a single nested doc. That's to make sure we get the correct context.
      // Otherwise we would double-call the setter, see gh-7196.
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (schema.$isMongooseDocumentArray &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] != null &&
        val[0].$__ != null &&
        val[0].$__.populated != null) {
      const populatedPaths = Object.keys(val[0].$__.populated);
      for (const populatedPath of populatedPaths) {
        this.populated(path + '.' + populatedPath,
          val.map(v => v.populated(populatedPath)),
          val[0].$__.populated[populatedPath].options);
      }
      didPopulate = true;
    }

    if (!didPopulate && this.$__.populated) {
      // If this array partially contains populated documents, convert them
      // all to ObjectIds re: #8443
      if (Array.isArray(val) && this.$__.populated[path]) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] instanceof Document) {
            val[i] = val[i]._id;
          }
        }
      }
      delete this.$__.populated[path];
    }

    if (schema.$isSingleNested && val != null) {
      _checkImmutableSubpaths(val, schema, priorVal);
    }

    this.$markValid(path);
  } catch (e) {
    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
      this.invalidate(path, e);
    } else if (e instanceof MongooseError.CastError) {
      this.invalidate(e.path, e);
      if (e.$originalErrorPath) {
        this.invalidate(path,
          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
      }
    } else {
      this.invalidate(path,
        new MongooseError.CastError(schema.instance, val, path, e));
    }
    shouldSet = false;
  }

  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);

    if (this.$__.savedState != null) {
      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        this.$__.savedState[path] = priorVal;
      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {
        this.unmarkModified(path);
      }
    }
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
}
                                              </=></td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $set(path, val, type, options) {

  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }

  if (path == null) {
    const _ = path;
    path = val;
    val = _;
  } else if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path instanceof Document) {
      if (path.$__isNested) {
        path = path.toObject();
      } else {
        path = path._doc;
      }
    }
    if (path == null) {
      const _ = path;
      path = val;
      val = _;
    }

    prefix = val ? val + '.' : '';
    keys = Object.keys(path);
    const len = keys.length;

    // `_skipMinimizeTopLevel` is because we may have deleted the top-level
    // nested key to ensure key order.
    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);
    if (len === 0 && _skipMinimizeTopLevel) {
      delete options._skipMinimizeTopLevel;
      if (val) {
        this.$set(val, {});
      }
      return this;
    }

    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix + key;
      pathtype = this.schema.pathType(pathName);

      // On initial set, delete any nested keys if we're going to overwrite
      // them to ensure we keep the user's key order.
      if (type === true &&
          !prefix &&
          path[key] != null &&
          pathtype === 'nested' &&
          this._doc[key] != null &&
          Object.keys(this._doc[key]).length === 0) {
        delete this._doc[key];
        // Make sure we set `{}` back even if we minimize re: gh-8565
        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
      }

      const someCondition = typeof path[key] === 'object' &&
                            !utils.isNativeObject(path[key]) &&
                            !utils.isMongooseType(path[key]) &&
                            path[key] != null &&
                            pathtype !== 'virtual' &&
                            pathtype !== 'real' &&
                            pathtype !== 'adhocOrUndefined' &&
                            !(this.$__path(pathName) instanceof MixedSchema) &&
                            !(this.schema.paths[pathName] &&
                            this.schema.paths[pathName].options &&
                            this.schema.paths[pathName].options.ref);

      if (someCondition) {
        this.$__.$setCalled.add(prefix + key);
        this.$set(path[key], prefix + key, constructing, options);
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && path[key] === void 0 &&
            this.get(pathName) !== void 0) {
          continue;
        }

        if (pathtype === 'adhocOrUndefined') {
          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
        }

        if (pathtype === 'real' || pathtype === 'virtual') {
          // Check for setting single embedded schema to document (gh-3535)
          let p = path[key];
          if (this.schema.paths[pathName] &&
              this.schema.paths[pathName].$isSingleNested &&
              path[key] instanceof Document) {
            p = p.toObject({ virtuals: false, transform: false });
          }
          this.$set(prefix + key, p, constructing, options);
        } else if (pathtype === 'nested' && path[key] instanceof Document) {
          this.$set(prefix + key,
            path[key].toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, path[key]);
          } else {
            throw new StrictModeError(key);
          }
        }
      } else if (path[key] !== void 0) {
        this.$set(prefix + key, path[key], constructing, options);
      }
    }

    return this;
  } else {
    this.$__.$setCalled.add(path);
  }

  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
  val = handleSpreadDoc(val);

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const priorVal = this.$__getValue(path);
        this.$__.savedState[path] = priorVal;

        const keys = Object.keys(priorVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = priorVal[key];
        }
      }

      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }

      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {
        this.unmarkModified(path);
      } else {
        this.markModified(path);
      }
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.$__isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) { pathtomark="path;" } else for (i="0;" i < parts.length; ++i) const subpath="parts.slice(0," + 1).join('.'); if (this.get(subpath, null, getters: false })="==" null) break; (!pathtomark) this doc is being constructed we should not trigger getters priorval="(()" => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }

  // If overwriting a subdocument path, make sure to clear out
  // any errors _before_ setting, so new errors that happen
  // get persisted. Re: #9080
  if (schema.$isSingleNested || schema.$isMongooseArray) {
    _markValidSubpaths(this, path);
  }

  if (schema.$isSingleNested && val != null && merge) {
    if (val instanceof Document) {
      val = val.toObject({ virtuals: false, transform: false });
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      this.$set(path + '.' + key, val[key], constructing, options);
    }

    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      return modelName === model.modelName || modelName === model.baseModelName;
    })();

    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = true;
      didPopulate = true;
    }

    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      for (const doc of val) {
        doc.$__.wasPopulated = true;
      }
      didPopulate = true;
    }

    if (this.schema.singleNestedPaths[path] == null) {
      // If this path is underneath a single nested schema, we'll call the setter
      // later in `$__set()` because we don't take `_doc` when we iterate through
      // a single nested doc. That's to make sure we get the correct context.
      // Otherwise we would double-call the setter, see gh-7196.
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (schema.$isMongooseDocumentArray &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] != null &&
        val[0].$__ != null &&
        val[0].$__.populated != null) {
      const populatedPaths = Object.keys(val[0].$__.populated);
      for (const populatedPath of populatedPaths) {
        this.populated(path + '.' + populatedPath,
          val.map(v => v.populated(populatedPath)),
          val[0].$__.populated[populatedPath].options);
      }
      didPopulate = true;
    }

    if (!didPopulate && this.$__.populated) {
      // If this array partially contains populated documents, convert them
      // all to ObjectIds re: #8443
      if (Array.isArray(val) && this.$__.populated[path]) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] instanceof Document) {
            val[i] = val[i]._id;
          }
        }
      }
      delete this.$__.populated[path];
    }

    if (schema.$isSingleNested && val != null) {
      _checkImmutableSubpaths(val, schema, priorVal);
    }

    this.$markValid(path);
  } catch (e) {
    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
      this.invalidate(path, e);
    } else if (e instanceof MongooseError.CastError) {
      this.invalidate(e.path, e);
      if (e.$originalErrorPath) {
        this.invalidate(path,
          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
      }
    } else {
      this.invalidate(path,
        new MongooseError.CastError(schema.instance, val, path, e));
    }
    shouldSet = false;
  }

  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);

    if (this.$__.savedState != null) {
      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        this.$__.savedState[path] = priorVal;
      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {
        this.unmarkModified(path);
      }
    }
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
}
                                              </=></td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  if (this.isNew) {
    return true;
  }

  // Re: the note about gh-7196, `val` is the raw value without casting or
  // setters if the full path is under a single nested subdoc because we don't
  // want to double run setters. So don't set it as modified. See gh-7264.
  if (this.schema.singleNestedPaths[path] != null) {
    return false;
  }

  if (val === void 0 && !this.$__isSelected(path)) {
    // when a path is not selected in a query, its initial
    // value will be undefined.
    return true;
  }

  if (val === void 0 && path in this.$__.activePaths.states.default) {
    // we're just unsetting the default value which was never saved
    return false;
  }

  // gh-3992: if setting a populated field to a doc, don't mark modified
  // if they have the same _id
  if (this.populated(path) &&
      val instanceof Document &&
      deepEqual(val._id, priorVal)) {
    return false;
  }

  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {
    return true;
  }

  if (!constructing &&
      val !== null &&
      val !== undefined &&
      path in this.$__.activePaths.states.default &&
      deepEqual(val, schema.getDefault(this, constructing))) {
    // a path with a default was $unset on the server
    // and the user is setting it to the same value again
    return true;
  }
  return false;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  Embedded = Embedded || require('./types/embedded');

  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
    schema, val, priorVal);
  const _this = this;

  if (shouldModify) {
    this.markModified(pathToMark);

    // handle directly setting arrays (gh-1126)
    MongooseArray || (MongooseArray = require('./types/array'));
    if (val && val.isMongooseArray) {
      val._registerAtomic('$set', val);

      // Update embedded document parent references (gh-5189)
      if (val.isMongooseDocumentArray) {
        val.forEach(function(item) {
          item && item.__parentArray && (item.__parentArray = val);
        });
      }

      // Small hack for gh-1638: if we're overwriting the entire array, ignore
      // paths that were modified before the array overwrite
      this.$__.activePaths.forEach(function(modifiedPath) {
        if (modifiedPath.startsWith(path + '.')) {
          _this.$__.activePaths.ignore(modifiedPath);
        }
      });
    }
  }

  let obj = this._doc;
  let i = 0;
  const l = parts.length;
  let cur = '';

  for (; i < l; i++) {
    const next = i + 1;
    const last = next === l;
    cur += (cur ? '.' + parts[i] : parts[i]);
    if (specialProperties.has(parts[i])) {
      return;
    }

    if (last) {
      if (obj instanceof Map) {
        obj.set(parts[i], val);
      } else {
        obj[parts[i]] = val;
      }
    } else {
      if (utils.isPOJO(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else {
        obj[parts[i]] = obj[parts[i]] || {};
        obj = obj[parts[i]];
      }
    }
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  return utils.getValue(path, this._doc);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, val) {
  utils.setValue(path, val, this._doc);
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, type, options) {
  let adhoc;
  options = options || {};
  if (type) {
    adhoc = this.schema.interpretAsType(path, type, this.schema.options);
  }

  let schema = this.$__path(path);
  if (schema == null) {
    schema = this.schema.virtualpath(path);
  }
  if (schema instanceof MixedSchema) {
    const virtual = this.schema.virtualpath(path);
    if (virtual != null) {
      schema = virtual;
    }
  }
  const pieces = path.split('.');
  let obj = this._doc;

  if (schema instanceof VirtualType) {
    return schema.applyGetters(void 0, this);
  }

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[pieces[0]] == 'string') {
    pieces[0] = this.schema.aliases[pieces[0]];
  }

  for (let i = 0, l = pieces.length; i < l; i++) {
    if (obj && obj._doc) {
      obj = obj._doc;
    }

    if (obj == null) {
      obj = void 0;
    } else if (obj instanceof Map) {
      obj = obj.get(pieces[i], { getters: false });
    } else if (i === l - 1) {
      obj = utils.getValue(pieces[i], obj);
    } else {
      obj = obj[pieces[i]];
    }
  }

  if (adhoc) {
    obj = adhoc.cast(obj);
  }

  if (schema != null && options.getters !== false) {
    obj = schema.applyGetters(obj, this);
  } else if (this.schema.nested[path] && options.virtuals) {
    // Might need to apply virtuals if this is a nested path
    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });
  }

  return obj;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const adhocs = this.$__.adhocPaths;
  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;

  if (adhocType) {
    return adhocType;
  }
  return this.schema.path(path);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  this.$__.activePaths.init(path);
  delete this.$__.pathsToScopes[path];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return Object.keys(this.$__.activePaths.states.modify);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const isEmptyOptions = {
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  };

  if (arguments.length > 0) {
    const v = this.get(path);
    if (v == null) {
      return true;
    }
    if (typeof v !== 'object') {
      return false;
    }
    if (utils.isPOJO(v)) {
      return _isEmpty(v);
    }
    return Object.keys(v.toObject(isEmptyOptions)).length === 0;
  }

  return Object.keys(this.toObject(isEmptyOptions)).length === 0;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  options = options || {};
  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  const _this = this;
  return directModifiedPaths.reduce(function(list, path) {
    const parts = path.split('.');
    list = list.concat(parts.reduce(function(chains, part, i) {
      return chains.concat(parts.slice(0, i).concat(part).join('.'));
    }, []).filter(function(chain) {
      return (list.indexOf(chain) === -1);
    }));

    if (!options.includeChildren) {
      return list;
    }

    let cur = _this.get(path);
    if (cur != null && typeof cur === 'object') {
      if (cur._doc) {
        cur = cur._doc;
      }
      if (Array.isArray(cur)) {
        const len = cur.length;
        for (let i = 0; i < len; ++i) {
          if (list.indexOf(path + '.' + i) === -1) {
            list.push(path + '.' + i);
            if (cur[i] != null && cur[i].$__) {
              const modified = cur[i].modifiedPaths();
              for (const childPath of modified) {
                list.push(path + '.' + i + '.' + childPath);
              }
            }
          }
        }
      } else {
        Object.keys(cur).
          filter(function(key) {
            return list.indexOf(path + '.' + key) === -1;
          }).
          forEach(function(key) {
            list.push(path + '.' + key);
          });
      }
    }

    return list;
  }, []);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(paths, modifiedPaths) {
  if (paths) {
    if (!Array.isArray(paths)) {
      paths = paths.split(' ');
    }
    const modified = modifiedPaths || this[documentModifiedPaths]();
    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
    const isModifiedChild = paths.some(function(path) {
      return !!~modified.indexOf(path);
    });

    return isModifiedChild || paths.some(function(path) {
      return directModifiedPaths.some(function(mod) {
        return mod === path || path.startsWith(mod + '.');
      });
    });
  }

  return this.$__.activePaths.some('modify');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('default');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.default.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(val) {
  if (arguments.length === 0) {
    return !!this.$__.isDeleted;
  }

  this.$__.isDeleted = !!val;
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('modify');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.modify.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('init');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.init.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__isSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (path in this.$__.selected) {
    return inclusive;
  }

  const pathDot = path + '.';

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }

    if (cur.startsWith(pathDot)) {
      return inclusive || cur !== pathDot;
    }

    if (pathDot.startsWith(cur + '.')) {
      return inclusive;
    }
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__isSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (path in this.$__.selected) {
    return inclusive;
  }

  const pathDot = path + '.';

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }

    if (cur.startsWith(pathDot)) {
      return inclusive || cur !== pathDot;
    }

    if (pathDot.startsWith(cur + '.')) {
      return inclusive;
    }
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isDirectSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.isDirectSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (this.$__.selected.hasOwnProperty(path)) {
    return inclusive;
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options, callback) {
  let parallelValidate;
  this.$op = 'validate';

  if (this.ownerDocument != null) {
    // Skip parallel validate check for subdocuments
  } else if (this.$__.validating) {
    parallelValidate = new ParallelValidateError(this, {
      parentStack: options && options.parentStack,
      conflictStack: this.$__.validating.stack
    });
  } else {
    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
  }

  if (typeof pathsToValidate === 'function') {
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = pathsToValidate;
    pathsToValidate = null;
  }

  return promiseOrCallback(callback, cb => {
    if (parallelValidate != null) {
      return cb(parallelValidate);
    }

    this.$__validate(pathsToValidate, options, (error) => {
      this.$op = null;
      cb(error);
    });
  }, this.constructor.events);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options) {
  const _this = this;

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }

  if (typeof pathsToValidate === 'string') {
    pathsToValidate = pathsToValidate.split(' ');
  }

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];

  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  }
  const validating = {};

  paths.forEach(function(path) {
    if (validating[path]) {
      return;
    }

    validating[path] = true;

    const p = _this.schema.path(path);
    if (!p) {
      return;
    }
    if (!_this.$isValid(path)) {
      return;
    }

    const val = _this.$__getValue(path);
    const err = p.doValidateSync(val, _this, {
      skipSchemaValidators: skipSchemaValidators[path],
      path: path
    });
    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
      if (p.$isSingleNested &&
          err instanceof ValidationError &&
          p.schema.options.storeSubdocValidationError === false) {
        return;
      }
      _this.invalidate(path, err, undefined, true);
    }
  });

  const err = _this.$__.validationError;
  _this.$__.validationError = undefined;
  _this.emit('validate', _this);
  _this.constructor.emit('validate', _this);

  if (err) {
    for (const key in err.errors) {
      // Make sure cast errors persist
      if (err.errors[key] instanceof MongooseError.CastError) {
        _this.invalidate(key, err.errors[key]);
      }
    }
  }

  return err;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function reset() {
  let _this = this;
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  this.$__.activePaths
    .map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    })
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    })
    .forEach(function(array) {
      let i = array.length;
      while (i--) {
        const doc = array[i];
        if (!doc) {
          continue;
        }
        doc.$__reset();
      }

      _this.$__.activePaths.init(array.$path());

      array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
      array[arrayAtomicsSymbol] = {};
    });

  this.$__.activePaths.
    map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    }).
    filter(function(val) {
      return val && val.$isSingleNested;
    }).
    forEach(function(doc) {
      doc.$__reset();
      _this.$__.activePaths.init(doc.$basePath);
    });

  // clear atomics
  this.$__dirty().forEach(function(dirt) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol]) {
      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
      type[arrayAtomicsSymbol] = {};
    }
  });

  this.$__.backup = {};
  this.$__.backup.activePaths = {
    modify: Object.assign({}, this.$__.activePaths.states.modify),
    default: Object.assign({}, this.$__.activePaths.states.default)
  };
  this.$__.backup.validationError = this.$__.validationError;
  this.$__.backup.errors = this.errors;

  // Clear 'dirty' cache
  this.$__.activePaths.clear('modify');
  this.$__.activePaths.clear('default');
  this.$__.validationError = undefined;
  this.errors = undefined;
  _this = this;
  this.schema.requiredPaths().forEach(function(path) {
    _this.$__.activePaths.require(path);
  });

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $__undoReset() {
  if (this.$__.backup == null || this.$__.backup.activePaths == null) {
    return;
  }

  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;

  this.$__.validationError = this.$__.backup.validationError;
  this.errors = this.$__.backup.errors;

  for (const dirt of this.$__dirty()) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
    }
  }

  for (const subdoc of this.$__getAllSubdocs()) {
    subdoc.$__undoReset();
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const _this = this;

  let all = this.$__.activePaths.map('modify', function(path) {
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  });

  // gh-2558: if we had to set a default and the value is not undefined,
  // we have to save as well
  all = all.concat(this.$__.activePaths.map('default', function(path) {
    if (path === '_id' || _this.$__getValue(path) == null) {
      return;
    }
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  }));

  // Sort dirty paths in a flat hierarchy.
  all.sort(function(a, b) {
    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
  });

  // Ignore "foo.a" if "foo" is dirty already.
  const minimal = [];
  let lastPath;
  let top;

  all.forEach(function(item) {
    if (!item) {
      return;
    }
    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {
      lastPath = item.path + '.';
      minimal.push(item);
      top = item;
    } else if (top != null &&
        top.value != null &&
        top.value[arrayAtomicsSymbol] != null &&
        top.value.hasAtomics()) {
      // special case for top level MongooseArrays
      // the `top` array itself and a sub path of `top` are being modified.
      // the only way to honor all of both modifications is through a $set
      // of entire array.
      top.value[arrayAtomicsSymbol] = {};
      top.value[arrayAtomicsSymbol].$set = top.value;
    }
  });

  top = lastPath = null;
  return minimal;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(schema) {
  schema.plugin(idGetter, { deduplicate: true });
  compile(schema.tree, this, undefined, schema.options);

  // Apply default getters if virtual doesn't have any (gh-6262)
  for (const key of Object.keys(schema.virtuals)) {
    schema.virtuals[key]._applyDefaultGetters();
  }

  this.schema = schema;
  this[documentSchemaSymbol] = schema;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  // validate all document arrays.
  return this.$__.activePaths
    .map('init', 'modify', function(i) {
      return this.$__getValue(i);
    }.bind(this))
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    }).reduce(function(seed, array) {
      return seed.concat(array);
    }, [])
    .filter(function(doc) {
      return doc;
    });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));
  Embedded = Embedded || require('./types/embedded');

  function docReducer(doc, seed, path) {
    let val = doc;
    if (path) {
      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
        val = doc._doc[path];
      } else {
        val = doc[path];
      }
    }
    if (val instanceof Embedded) {
      seed.push(val);
    } else if (val instanceof Map) {
      seed = Array.from(val.keys()).reduce(function(seed, path) {
        return docReducer(val.get(path), seed, null);
      }, seed);
    } else if (val && val.$isSingleNested) {
      seed = Object.keys(val._doc).reduce(function(seed, path) {
        return docReducer(val._doc, seed, path);
      }, seed);
      seed.push(val);
    } else if (val && val.isMongooseDocumentArray) {
      val.forEach(function _docReduce(doc) {
        if (!doc || !doc._doc) {
          return;
        }
        seed = Object.keys(doc._doc).reduce(function(seed, path) {
          return docReducer(doc._doc, seed, path);
        }, seed);
        if (doc instanceof Embedded) {
          seed.push(doc);
        }
      });
    } else if (val instanceof Document && val.$__isNested) {
      seed = Object.keys(val).reduce(function(seed, path) {
        return docReducer(val, seed, path);
      }, seed);
    }
    return seed;
  }

  const _this = this;
  const subDocs = Object.keys(this._doc).reduce(function(seed, path) {
    return docReducer(_this, seed, path);
  }, []);

  return subDocs;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function handleReject(err) {
  // emit on the Model if listening
  if (this.listeners('error').length) {
    this.emit('error', err);
  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {
    this.constructor.emit('error', err);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, json) {
  let defaultOptions = {
    transform: true,
    flattenDecimals: true
  };

  const path = json ? 'toJSON' : 'toObject';
  const baseOptions = get(this, 'constructor.base.options.' + path, {});
  const schemaOptions = get(this, 'schema.options', {});
  // merge base default options with Schema's set default options if available.
  // `clone` is necessary here because `utils.options` directly modifies the second input.
  defaultOptions = utils.options(defaultOptions, clone(baseOptions));
  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));

  // If options do not exist or is not an object, set it to empty object
  options = utils.isPOJO(options) ? clone(options) : {};
  options._calledWithOptions = options._calledWithOptions || clone(options);

  if (!('flattenMaps' in options)) {
    options.flattenMaps = defaultOptions.flattenMaps;
  }

  let _minimize;
  if (options._calledWithOptions.minimize != null) {
    _minimize = options.minimize;
  } else if (defaultOptions.minimize != null) {
    _minimize = defaultOptions.minimize;
  } else {
    _minimize = schemaOptions.minimize;
  }

  // The original options that will be passed to `clone()`. Important because
  // `clone()` will recursively call `$toObject()` on embedded docs, so we
  // need the original options the user passed in, plus `_isNested` and
  // `_parentOptions` for checking whether we need to depopulate.
  const cloneOptions = Object.assign(utils.clone(options), {
    _isNested: true,
    json: json,
    minimize: _minimize
  });

  if (utils.hasUserDefinedProperty(options, 'getters')) {
    cloneOptions.getters = options.getters;
  }
  if (utils.hasUserDefinedProperty(options, 'virtuals')) {
    cloneOptions.virtuals = options.virtuals;
  }

  const depopulate = options.depopulate ||
    get(options, '_parentOptions.depopulate', false);
  // _isNested will only be true if this is not the top level document, we
  // should never depopulate
  if (depopulate && options._isNested && this.$__.wasPopulated) {
    // populated paths that we set to a document
    return clone(this._id, cloneOptions);
  }

  // merge default options with input options.
  options = utils.options(defaultOptions, options);
  options._isNested = true;
  options.json = json;
  options.minimize = _minimize;

  cloneOptions._parentOptions = options;
  cloneOptions._skipSingleNestedGetters = true;

  const gettersOptions = Object.assign({}, cloneOptions);
  gettersOptions._skipSingleNestedGetters = false;

  // remember the root transform function
  // to save it from being overwritten by sub-transform functions
  const originalTransform = options.transform;

  let ret = clone(this._doc, cloneOptions) || {};

  if (options.getters) {
    applyGetters(this, ret, gettersOptions);

    if (options.minimize) {
      ret = minimize(ret) || {};
    }
  }

  if (options.virtuals || (options.getters && options.virtuals !== false)) {
    applyVirtuals(this, ret, gettersOptions, options);
  }

  if (options.versionKey === false && this.schema.options.versionKey) {
    delete ret[this.schema.options.versionKey];
  }

  let transform = options.transform;

  // In the case where a subdocument has its own transform function, we need to
  // check and see if the parent has a transform (options.transform) and if the
  // child schema has a transform (this.schema.options.toObject) In this case,
  // we need to adjust options.transform to be the child schema's transform and
  // not the parent schema's
  if (transform) {
    applySchemaTypeTransforms(this, ret);
  }

  if (options.useProjection) {
    omitDeselectedFields(this, ret);
  }

  if (transform === true || (schemaOptions.toObject && transform)) {
    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;

    if (opts) {
      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
    }
  } else {
    options.transform = originalTransform;
  }

  if (typeof transform === 'function') {
    const xformed = transform(this, ret, options);
    if (typeof xformed !== 'undefined') {
      ret = xformed;
    }
  }

  return ret;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  return this.$toObject(options);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  return this.$toObject(options, true);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const ret = this.inspect();
  if (typeof ret === 'string') {
    return ret;
  }
  return inspect(ret);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(doc) {
  if (!doc) {
    return false;
  }

  const tid = this.$__getValue('_id');
  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;
  if (!tid && !docid) {
    return deepEqual(this, doc);
  }
  return tid && tid.equals
    ? tid.equals(docid)
    : tid === docid;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(callback) {
  const isUsingShorthand = callback != null && typeof callback !== 'function';
  if (isUsingShorthand) {
    return this.populate.apply(this, arguments).execPopulate();
  }

  return promiseOrCallback(callback, cb => {
    this.populate(cb);
  }, this.constructor.events);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, val, options) {
  // val and options are internal
  if (val === null || val === void 0) {
    if (!this.$__.populated) {
      return undefined;
    }
    const v = this.$__.populated[path];
    if (v) {
      return v.value;
    }
    return undefined;
  }

  // internal
  if (val === true) {
    if (!this.$__.populated) {
      return undefined;
    }
    return this.$__.populated[path];
  }

  this.$__.populated || (this.$__.populated = {});
  this.$__.populated[path] = { value: val, options: options };

  // If this was a nested populate, make sure each populated doc knows
  // about its populated children (gh-7685)
  const pieces = path.split('.');
  for (let i = 0; i < pieces.length - 1; ++i) {
    const subpath = pieces.slice(0, i + 1).join('.');
    const subdoc = this.get(subpath);
    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
      const rest = pieces.slice(i + 1).join('.');
      subdoc.populated(rest, val, options);
      // No need to continue because the above recursion should take care of
      // marking the rest of the docs as populated
      break;
    }
  }

  return val;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (typeof path === 'string') {
    path = path.split(' ');
  }

  let populatedIds;
  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
  const populated = get(this, '$__.populated', {});

  if (arguments.length === 0) {
    // Depopulate all
    for (const virtualKey of virtualKeys) {
      delete this.$$populatedVirtuals[virtualKey];
      delete this._doc[virtualKey];
      delete populated[virtualKey];
    }

    const keys = Object.keys(populated);

    for (const key of keys) {
      populatedIds = this.populated(key);
      if (!populatedIds) {
        continue;
      }
      delete populated[key];
      this.$set(key, populatedIds);
    }
    return this;
  }

  for (const singlePath of path) {
    populatedIds = this.populated(singlePath);
    delete populated[singlePath];

    if (virtualKeys.indexOf(singlePath) !== -1) {
      delete this.$$populatedVirtuals[singlePath];
      delete this._doc[singlePath];
    } else if (populatedIds) {
      this.$set(singlePath, populatedIds);
    }
  }
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const delta = this.$__delta();
  const changes = delta ? delta[1] : {};
  return changes;
}
                                              </td>
                                              
                                          </tr>
                                          
                                          <tr>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  {
  _id: 60735418b255ff0b80680324,
  questionId: 15,
  question: 'What is formal testing?',
  answer: 'Verification of software, according to the test plan, test procedures and relevant documentation, taking into account the wishes of the client',
  rightAnswer: false
},{
  _id: 60735418b255ff0b80680325,
  questionId: 8,
  question: "Agile's main ideas",
  answer: 'All options are incorrect',
  rightAnswer: false
},{
  _id: 60735418b255ff0b80680326,
  questionId: 22,
  question: 'This is a comprehensive user testing of concurrent access to an application to verify the impact on a code, module or database. Mainly detects deadlocks in code.',
  answer: 'Currency testing',
  rightAnswer: true
},{
  _id: 60735418b255ff0b80680327,
  questionId: 18,
  question: 'Which of the following is superfluous',
  answer: 'Check list',
  rightAnswer: false
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  2
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  true
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  false
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  22
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  This is a comprehensive user testing of concurrent access to an application to verify the impact on a code, module or database. Mainly detects deadlocks in code.
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  Currency testing
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  true
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  60735418b255ff0b80680326
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  60735418b255ff0b80680326
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function EmbeddedDocument() {
    Subdocument.apply(this, arguments);

    this.$session(this.ownerDocument().$session());
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  questions
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options, callback) {
  if (typeof pathsToValidate === 'function') {
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }

  const _this = this;
  const _complete = () => {
    let validationError = this.$__.validationError;
    this.$__.validationError = undefined;

    if (shouldValidateModifiedOnly && validationError != null) {
      // Remove any validation errors that aren't from modified paths
      const errors = Object.keys(validationError.errors);
      for (const errPath of errors) {
        if (!this.isModified(errPath)) {
          delete validationError.errors[errPath];
        }
      }
      if (Object.keys(validationError.errors).length === 0) {
        validationError = void 0;
      }
    }

    this.$__.cachedRequired = {};
    this.emit('validate', _this);
    this.constructor.emit('validate', _this);

    this.$__.validating = null;
    if (validationError) {
      for (const key in validationError.errors) {
        // Make sure cast errors persist
        if (!this[documentArrayParent] &&
            validationError.errors[key] instanceof MongooseError.CastError) {
          this.invalidate(key, validationError.errors[key]);
        }
      }

      return validationError;
    }
  };

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];
  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  }
  if (paths.length === 0) {
    return process.nextTick(function() {
      const error = _complete();
      if (error) {
        return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
          callback(error);
        });
      }
      callback(null, _this);
    });
  }

  const validated = {};
  let total = 0;

  const complete = function() {
    const error = _complete();
    if (error) {
      return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
        callback(error);
      });
    }
    callback(null, _this);
  };

  const validatePath = function(path) {
    if (path == null || validated[path]) {
      return;
    }

    validated[path] = true;
    total++;

    process.nextTick(function() {
      const schemaType = _this.schema.path(path);

      if (!schemaType) {
        return --total || complete();
      }

      // If user marked as invalid or there was a cast error, don't validate
      if (!_this.$isValid(path)) {
        --total || complete();
        return;
      }

      let val = _this.$__getValue(path);

      // If you `populate()` and get back a null value, required validators
      // shouldn't fail (gh-8018). We should always fall back to the populated
      // value.
      let pop;
      if (val == null && (pop = _this.populated(path))) {
        val = pop;
      }
      const scope = path in _this.$__.pathsToScopes ?
        _this.$__.pathsToScopes[path] :
        _this;

      const doValidateOptions = {
        skipSchemaValidators: skipSchemaValidators[path],
        path: path
      };
      schemaType.doValidate(val, function(err) {
        if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
          if (schemaType.$isSingleNested &&
              err instanceof ValidationError &&
              schemaType.schema.options.storeSubdocValidationError === false) {
            return --total || complete();
          }
          _this.invalidate(path, err, undefined, true);
        }
        --total || complete();
      }, scope, doValidateOptions);
    });
  };

  const numPaths = paths.length;
  for (let i = 0; i < numPaths; ++i) {
    validatePath(paths[i]);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
    var _context = context || this;
    var args = Array.prototype.slice.call(arguments);
    _this.wrap(name, fn, _context, args, options);
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      process.nextTick(() => fn.apply(this, arguments));
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
    var _context = context || this;
    var args = Array.prototype.slice.call(arguments);
    _this.wrap(name, fn, _context, args, options);
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      process.nextTick(() => fn.apply(this, arguments));
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function syncWrapper() {
    kareem.execPreSync(name, this, arguments);

    var toReturn = fn.apply(this, arguments);

    kareem.execPostSync(name, this, [toReturn]);

    return toReturn;
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.toObject(internalToObjectOptions);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(index) {
  this.__index = index;

  if (get(this, '$__.validationError', null) != null) {
    const keys = Object.keys(this.$__.validationError.errors);
    for (const key of keys) {
      this.invalidate(key, this.$__.validationError.errors[key]);
    }
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  this.$__.activePaths.modify(path);
  if (!this.__parentArray) {
    return;
  }

  const pathToCheck = this.__parentArray.$path() + '.0.' + path;
  if (this.isNew && this.ownerDocument().$__isSelected(pathToCheck)) {
    // Mark the WHOLE parent array as modified
    // if this is a new document (i.e., we are initializing
    // a document),
    this.__parentArray._markModified();
  } else {
    this.__parentArray._markModified(this, path);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  throw new Error('Mongoose does not support calling populate() on nested ' +
    'docs. Instead of `doc.arr[0].populate("path")`, use ' +
    '`doc.populate("arr.0.path")`');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = {};
  }
  options = options || {};

  if (!options.suppressWarning) {
    console.warn('mongoose: calling `save()` on a subdoc does **not** save ' +
      'the document to MongoDB, it only runs save middleware. ' +
      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +
      'if you\'re sure this behavior is right for your app.');
  }

  return promiseOrCallback(fn, cb => {
    this.$__save(cb);
  });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, fn) {
  if (typeof options === 'function' && !fn) {
    fn = options;
    options = undefined;
  }
  if (!this.__parentArray || (options && options.noop)) {
    this.$__remove(fn);
    return this;
  }

  let _id;
  if (!this.willRemove) {
    _id = this._doc._id;
    if (!_id) {
      throw new Error('For your own good, Mongoose does not know ' +
          'how to remove an EmbeddedDocument that has no _id');
    }
    this.__parentArray.pull({ _id: _id });
    this.willRemove = true;
    registerRemoveListener(this);
  }

  this.$__remove(fn);

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  throw new Error('The #update method is not available on EmbeddedDocuments');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.toObject({
    transform: false,
    virtuals: false,
    flattenDecimals: false
  });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, err, val) {
  Document.prototype.invalidate.call(this, path, err, val);

  if (!this[documentArrayParent] || this.__index == null) {
    if (err[validatorErrorSymbol] || err instanceof ValidationError) {
      return this.ownerDocument().$__.validationError;
    }
    throw err;
  }

  const index = this.__index;
  const parentPath = this.__parentArray.$path();
  const fullPath = [parentPath, index, path].join('.');
  this[documentArrayParent].invalidate(fullPath, err, val);

  return this.ownerDocument().$__.validationError;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (!this[documentArrayParent]) {
    return;
  }

  const index = this.__index;
  if (typeof index !== 'undefined') {
    const parentPath = this.__parentArray.$path();
    const fullPath = [parentPath, index, path].join('.');
    this[documentArrayParent].$markValid(fullPath);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  Document.prototype.$ignore.call(this, path);

  if (!this[documentArrayParent]) {
    return;
  }

  const index = this.__index;
  if (typeof index !== 'undefined') {
    const parentPath = this.__parentArray.$path();
    const fullPath = [parentPath, index, path].join('.');
    this[documentArrayParent].$ignore(fullPath);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const index = this.__index;
  if (typeof index !== 'undefined' && this[documentArrayParent]) {
    return !this[documentArrayParent].$__.validationError ||
      !this[documentArrayParent].$__.validationError.errors[this.$__fullPath(path)];
  }

  return true;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  if (this.$__.ownerDocument) {
    return this.$__.ownerDocument;
  }

  let parent = this[documentArrayParent];
  if (!parent) {
    return this;
  }

  while (parent[documentArrayParent] || parent.$__parent) {
    parent = parent[documentArrayParent] || parent.$__parent;
  }

  this.$__.ownerDocument = parent;
  return this.$__.ownerDocument;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (!this.$__.fullPath) {
    let parent = this; // eslint-disable-line consistent-this
    if (!parent[documentArrayParent]) {
      return path;
    }

    const paths = [];
    while (parent[documentArrayParent] || parent.$__parent) {
      if (parent[documentArrayParent]) {
        paths.unshift(parent.__parentArray.$path());
      } else {
        paths.unshift(parent.$basePath);
      }
      parent = parent[documentArrayParent] || parent.$__parent;
    }

    this.$__.fullPath = paths.join('.');

    if (!this.$__.ownerDocument) {
      // optimization
      this.$__.ownerDocument = parent;
    }
  }

  return path
    ? this.$__.fullPath + '.' + path
    : this.$__.fullPath;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this[documentArrayParent];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this[documentArrayParent];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.__parentArray;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(obj, fields, skipId, exclude, hasIncludedChildren) {
  const doc = {};

  const paths = Object.keys(this.schema.paths).
    // Don't build up any paths that are underneath a map, we don't know
    // what the keys will be
    filter(p => !p.includes('$*'));
  const plen = paths.length;
  let ii = 0;

  for (; ii < plen; ++ii) {
    const p = paths[ii];

    if (p === '_id') {
      if (skipId) {
        continue;
      }
      if (obj && '_id' in obj) {
        continue;
      }
    }

    const path = p.split('.');
    const len = path.length;
    const last = len - 1;
    let curPath = '';
    let doc_ = doc;
    let included = false;

    for (let i = 0; i < len; ++i) {
      const piece = path[i];

      curPath += (!curPath.length ? '' : '.') + piece;

      // support excluding intermediary levels
      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }

      if (i < last) {
        doc_ = doc_[piece] || (doc_[piece] = {});
      }
    }
  }

  this._doc = doc;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(doc, opts, fn) {
  if (typeof opts === 'function') {
    fn = opts;
    opts = null;
  }

  this.$__init(doc, opts);

  if (fn) {
    fn(null, this);
  }

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function updateOne(doc, options, callback) {
  const query = this.constructor.updateOne({ _id: this._id }, doc, options);
  query._pre(cb => {
    this.constructor._middleware.execPre('updateOne', this, [this], cb);
  });
  query._post(cb => {
    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);
  });

  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }

  if (callback != null) {
    return query.exec(callback);
  }

  return query;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function replaceOne() {
  const args = utils.args(arguments);
  args.unshift({ _id: this._id });
  return this.constructor.replaceOne.apply(this.constructor, args);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $session(session) {
  if (arguments.length === 0) {
    return this.$__.session;
  }
  this.$__.session = session;

  if (!this.ownerDocument) {
    const subdocs = this.$__getAllSubdocs();
    for (const child of subdocs) {
      child.$session(session);
    }
  }

  return session;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function overwrite(obj) {
  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));

  for (const key of keys) {
    if (key === '_id') {
      continue;
    }
    // Explicitly skip version key
    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {
      continue;
    }
    if (this.schema.options.discriminatorKey && key === this.schema.options.discriminatorKey) {
      continue;
    }
    this.$set(key, obj[key]);
  }

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $set(path, val, type, options) {

  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }

  if (path == null) {
    const _ = path;
    path = val;
    val = _;
  } else if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path instanceof Document) {
      if (path.$__isNested) {
        path = path.toObject();
      } else {
        path = path._doc;
      }
    }
    if (path == null) {
      const _ = path;
      path = val;
      val = _;
    }

    prefix = val ? val + '.' : '';
    keys = Object.keys(path);
    const len = keys.length;

    // `_skipMinimizeTopLevel` is because we may have deleted the top-level
    // nested key to ensure key order.
    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);
    if (len === 0 && _skipMinimizeTopLevel) {
      delete options._skipMinimizeTopLevel;
      if (val) {
        this.$set(val, {});
      }
      return this;
    }

    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix + key;
      pathtype = this.schema.pathType(pathName);

      // On initial set, delete any nested keys if we're going to overwrite
      // them to ensure we keep the user's key order.
      if (type === true &&
          !prefix &&
          path[key] != null &&
          pathtype === 'nested' &&
          this._doc[key] != null &&
          Object.keys(this._doc[key]).length === 0) {
        delete this._doc[key];
        // Make sure we set `{}` back even if we minimize re: gh-8565
        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
      }

      const someCondition = typeof path[key] === 'object' &&
                            !utils.isNativeObject(path[key]) &&
                            !utils.isMongooseType(path[key]) &&
                            path[key] != null &&
                            pathtype !== 'virtual' &&
                            pathtype !== 'real' &&
                            pathtype !== 'adhocOrUndefined' &&
                            !(this.$__path(pathName) instanceof MixedSchema) &&
                            !(this.schema.paths[pathName] &&
                            this.schema.paths[pathName].options &&
                            this.schema.paths[pathName].options.ref);

      if (someCondition) {
        this.$__.$setCalled.add(prefix + key);
        this.$set(path[key], prefix + key, constructing, options);
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && path[key] === void 0 &&
            this.get(pathName) !== void 0) {
          continue;
        }

        if (pathtype === 'adhocOrUndefined') {
          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
        }

        if (pathtype === 'real' || pathtype === 'virtual') {
          // Check for setting single embedded schema to document (gh-3535)
          let p = path[key];
          if (this.schema.paths[pathName] &&
              this.schema.paths[pathName].$isSingleNested &&
              path[key] instanceof Document) {
            p = p.toObject({ virtuals: false, transform: false });
          }
          this.$set(prefix + key, p, constructing, options);
        } else if (pathtype === 'nested' && path[key] instanceof Document) {
          this.$set(prefix + key,
            path[key].toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, path[key]);
          } else {
            throw new StrictModeError(key);
          }
        }
      } else if (path[key] !== void 0) {
        this.$set(prefix + key, path[key], constructing, options);
      }
    }

    return this;
  } else {
    this.$__.$setCalled.add(path);
  }

  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
  val = handleSpreadDoc(val);

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const priorVal = this.$__getValue(path);
        this.$__.savedState[path] = priorVal;

        const keys = Object.keys(priorVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = priorVal[key];
        }
      }

      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }

      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {
        this.unmarkModified(path);
      } else {
        this.markModified(path);
      }
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.$__isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) { pathtomark="path;" } else for (i="0;" i < parts.length; ++i) const subpath="parts.slice(0," + 1).join('.'); if (this.get(subpath, null, getters: false })="==" null) break; (!pathtomark) this doc is being constructed we should not trigger getters priorval="(()" => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }

  // If overwriting a subdocument path, make sure to clear out
  // any errors _before_ setting, so new errors that happen
  // get persisted. Re: #9080
  if (schema.$isSingleNested || schema.$isMongooseArray) {
    _markValidSubpaths(this, path);
  }

  if (schema.$isSingleNested && val != null && merge) {
    if (val instanceof Document) {
      val = val.toObject({ virtuals: false, transform: false });
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      this.$set(path + '.' + key, val[key], constructing, options);
    }

    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      return modelName === model.modelName || modelName === model.baseModelName;
    })();

    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = true;
      didPopulate = true;
    }

    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      for (const doc of val) {
        doc.$__.wasPopulated = true;
      }
      didPopulate = true;
    }

    if (this.schema.singleNestedPaths[path] == null) {
      // If this path is underneath a single nested schema, we'll call the setter
      // later in `$__set()` because we don't take `_doc` when we iterate through
      // a single nested doc. That's to make sure we get the correct context.
      // Otherwise we would double-call the setter, see gh-7196.
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (schema.$isMongooseDocumentArray &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] != null &&
        val[0].$__ != null &&
        val[0].$__.populated != null) {
      const populatedPaths = Object.keys(val[0].$__.populated);
      for (const populatedPath of populatedPaths) {
        this.populated(path + '.' + populatedPath,
          val.map(v => v.populated(populatedPath)),
          val[0].$__.populated[populatedPath].options);
      }
      didPopulate = true;
    }

    if (!didPopulate && this.$__.populated) {
      // If this array partially contains populated documents, convert them
      // all to ObjectIds re: #8443
      if (Array.isArray(val) && this.$__.populated[path]) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] instanceof Document) {
            val[i] = val[i]._id;
          }
        }
      }
      delete this.$__.populated[path];
    }

    if (schema.$isSingleNested && val != null) {
      _checkImmutableSubpaths(val, schema, priorVal);
    }

    this.$markValid(path);
  } catch (e) {
    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
      this.invalidate(path, e);
    } else if (e instanceof MongooseError.CastError) {
      this.invalidate(e.path, e);
      if (e.$originalErrorPath) {
        this.invalidate(path,
          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
      }
    } else {
      this.invalidate(path,
        new MongooseError.CastError(schema.instance, val, path, e));
    }
    shouldSet = false;
  }

  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);

    if (this.$__.savedState != null) {
      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        this.$__.savedState[path] = priorVal;
      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {
        this.unmarkModified(path);
      }
    }
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
}
                                              </=></td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $set(path, val, type, options) {

  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }

  if (path == null) {
    const _ = path;
    path = val;
    val = _;
  } else if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path instanceof Document) {
      if (path.$__isNested) {
        path = path.toObject();
      } else {
        path = path._doc;
      }
    }
    if (path == null) {
      const _ = path;
      path = val;
      val = _;
    }

    prefix = val ? val + '.' : '';
    keys = Object.keys(path);
    const len = keys.length;

    // `_skipMinimizeTopLevel` is because we may have deleted the top-level
    // nested key to ensure key order.
    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);
    if (len === 0 && _skipMinimizeTopLevel) {
      delete options._skipMinimizeTopLevel;
      if (val) {
        this.$set(val, {});
      }
      return this;
    }

    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix + key;
      pathtype = this.schema.pathType(pathName);

      // On initial set, delete any nested keys if we're going to overwrite
      // them to ensure we keep the user's key order.
      if (type === true &&
          !prefix &&
          path[key] != null &&
          pathtype === 'nested' &&
          this._doc[key] != null &&
          Object.keys(this._doc[key]).length === 0) {
        delete this._doc[key];
        // Make sure we set `{}` back even if we minimize re: gh-8565
        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
      }

      const someCondition = typeof path[key] === 'object' &&
                            !utils.isNativeObject(path[key]) &&
                            !utils.isMongooseType(path[key]) &&
                            path[key] != null &&
                            pathtype !== 'virtual' &&
                            pathtype !== 'real' &&
                            pathtype !== 'adhocOrUndefined' &&
                            !(this.$__path(pathName) instanceof MixedSchema) &&
                            !(this.schema.paths[pathName] &&
                            this.schema.paths[pathName].options &&
                            this.schema.paths[pathName].options.ref);

      if (someCondition) {
        this.$__.$setCalled.add(prefix + key);
        this.$set(path[key], prefix + key, constructing, options);
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && path[key] === void 0 &&
            this.get(pathName) !== void 0) {
          continue;
        }

        if (pathtype === 'adhocOrUndefined') {
          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
        }

        if (pathtype === 'real' || pathtype === 'virtual') {
          // Check for setting single embedded schema to document (gh-3535)
          let p = path[key];
          if (this.schema.paths[pathName] &&
              this.schema.paths[pathName].$isSingleNested &&
              path[key] instanceof Document) {
            p = p.toObject({ virtuals: false, transform: false });
          }
          this.$set(prefix + key, p, constructing, options);
        } else if (pathtype === 'nested' && path[key] instanceof Document) {
          this.$set(prefix + key,
            path[key].toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, path[key]);
          } else {
            throw new StrictModeError(key);
          }
        }
      } else if (path[key] !== void 0) {
        this.$set(prefix + key, path[key], constructing, options);
      }
    }

    return this;
  } else {
    this.$__.$setCalled.add(path);
  }

  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
  val = handleSpreadDoc(val);

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const priorVal = this.$__getValue(path);
        this.$__.savedState[path] = priorVal;

        const keys = Object.keys(priorVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = priorVal[key];
        }
      }

      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }

      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {
        this.unmarkModified(path);
      } else {
        this.markModified(path);
      }
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.$__isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) { pathtomark="path;" } else for (i="0;" i < parts.length; ++i) const subpath="parts.slice(0," + 1).join('.'); if (this.get(subpath, null, getters: false })="==" null) break; (!pathtomark) this doc is being constructed we should not trigger getters priorval="(()" => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }

  // If overwriting a subdocument path, make sure to clear out
  // any errors _before_ setting, so new errors that happen
  // get persisted. Re: #9080
  if (schema.$isSingleNested || schema.$isMongooseArray) {
    _markValidSubpaths(this, path);
  }

  if (schema.$isSingleNested && val != null && merge) {
    if (val instanceof Document) {
      val = val.toObject({ virtuals: false, transform: false });
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      this.$set(path + '.' + key, val[key], constructing, options);
    }

    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      return modelName === model.modelName || modelName === model.baseModelName;
    })();

    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = true;
      didPopulate = true;
    }

    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      for (const doc of val) {
        doc.$__.wasPopulated = true;
      }
      didPopulate = true;
    }

    if (this.schema.singleNestedPaths[path] == null) {
      // If this path is underneath a single nested schema, we'll call the setter
      // later in `$__set()` because we don't take `_doc` when we iterate through
      // a single nested doc. That's to make sure we get the correct context.
      // Otherwise we would double-call the setter, see gh-7196.
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (schema.$isMongooseDocumentArray &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] != null &&
        val[0].$__ != null &&
        val[0].$__.populated != null) {
      const populatedPaths = Object.keys(val[0].$__.populated);
      for (const populatedPath of populatedPaths) {
        this.populated(path + '.' + populatedPath,
          val.map(v => v.populated(populatedPath)),
          val[0].$__.populated[populatedPath].options);
      }
      didPopulate = true;
    }

    if (!didPopulate && this.$__.populated) {
      // If this array partially contains populated documents, convert them
      // all to ObjectIds re: #8443
      if (Array.isArray(val) && this.$__.populated[path]) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] instanceof Document) {
            val[i] = val[i]._id;
          }
        }
      }
      delete this.$__.populated[path];
    }

    if (schema.$isSingleNested && val != null) {
      _checkImmutableSubpaths(val, schema, priorVal);
    }

    this.$markValid(path);
  } catch (e) {
    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
      this.invalidate(path, e);
    } else if (e instanceof MongooseError.CastError) {
      this.invalidate(e.path, e);
      if (e.$originalErrorPath) {
        this.invalidate(path,
          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
      }
    } else {
      this.invalidate(path,
        new MongooseError.CastError(schema.instance, val, path, e));
    }
    shouldSet = false;
  }

  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);

    if (this.$__.savedState != null) {
      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        this.$__.savedState[path] = priorVal;
      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {
        this.unmarkModified(path);
      }
    }
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
}
                                              </=></td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  if (this.isNew) {
    return true;
  }

  // Re: the note about gh-7196, `val` is the raw value without casting or
  // setters if the full path is under a single nested subdoc because we don't
  // want to double run setters. So don't set it as modified. See gh-7264.
  if (this.schema.singleNestedPaths[path] != null) {
    return false;
  }

  if (val === void 0 && !this.$__isSelected(path)) {
    // when a path is not selected in a query, its initial
    // value will be undefined.
    return true;
  }

  if (val === void 0 && path in this.$__.activePaths.states.default) {
    // we're just unsetting the default value which was never saved
    return false;
  }

  // gh-3992: if setting a populated field to a doc, don't mark modified
  // if they have the same _id
  if (this.populated(path) &&
      val instanceof Document &&
      deepEqual(val._id, priorVal)) {
    return false;
  }

  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {
    return true;
  }

  if (!constructing &&
      val !== null &&
      val !== undefined &&
      path in this.$__.activePaths.states.default &&
      deepEqual(val, schema.getDefault(this, constructing))) {
    // a path with a default was $unset on the server
    // and the user is setting it to the same value again
    return true;
  }
  return false;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  Embedded = Embedded || require('./types/embedded');

  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
    schema, val, priorVal);
  const _this = this;

  if (shouldModify) {
    this.markModified(pathToMark);

    // handle directly setting arrays (gh-1126)
    MongooseArray || (MongooseArray = require('./types/array'));
    if (val && val.isMongooseArray) {
      val._registerAtomic('$set', val);

      // Update embedded document parent references (gh-5189)
      if (val.isMongooseDocumentArray) {
        val.forEach(function(item) {
          item && item.__parentArray && (item.__parentArray = val);
        });
      }

      // Small hack for gh-1638: if we're overwriting the entire array, ignore
      // paths that were modified before the array overwrite
      this.$__.activePaths.forEach(function(modifiedPath) {
        if (modifiedPath.startsWith(path + '.')) {
          _this.$__.activePaths.ignore(modifiedPath);
        }
      });
    }
  }

  let obj = this._doc;
  let i = 0;
  const l = parts.length;
  let cur = '';

  for (; i < l; i++) {
    const next = i + 1;
    const last = next === l;
    cur += (cur ? '.' + parts[i] : parts[i]);
    if (specialProperties.has(parts[i])) {
      return;
    }

    if (last) {
      if (obj instanceof Map) {
        obj.set(parts[i], val);
      } else {
        obj[parts[i]] = val;
      }
    } else {
      if (utils.isPOJO(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else {
        obj[parts[i]] = obj[parts[i]] || {};
        obj = obj[parts[i]];
      }
    }
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  return utils.getValue(path, this._doc);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, val) {
  utils.setValue(path, val, this._doc);
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, type, options) {
  let adhoc;
  options = options || {};
  if (type) {
    adhoc = this.schema.interpretAsType(path, type, this.schema.options);
  }

  let schema = this.$__path(path);
  if (schema == null) {
    schema = this.schema.virtualpath(path);
  }
  if (schema instanceof MixedSchema) {
    const virtual = this.schema.virtualpath(path);
    if (virtual != null) {
      schema = virtual;
    }
  }
  const pieces = path.split('.');
  let obj = this._doc;

  if (schema instanceof VirtualType) {
    return schema.applyGetters(void 0, this);
  }

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[pieces[0]] == 'string') {
    pieces[0] = this.schema.aliases[pieces[0]];
  }

  for (let i = 0, l = pieces.length; i < l; i++) {
    if (obj && obj._doc) {
      obj = obj._doc;
    }

    if (obj == null) {
      obj = void 0;
    } else if (obj instanceof Map) {
      obj = obj.get(pieces[i], { getters: false });
    } else if (i === l - 1) {
      obj = utils.getValue(pieces[i], obj);
    } else {
      obj = obj[pieces[i]];
    }
  }

  if (adhoc) {
    obj = adhoc.cast(obj);
  }

  if (schema != null && options.getters !== false) {
    obj = schema.applyGetters(obj, this);
  } else if (this.schema.nested[path] && options.virtuals) {
    // Might need to apply virtuals if this is a nested path
    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });
  }

  return obj;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const adhocs = this.$__.adhocPaths;
  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;

  if (adhocType) {
    return adhocType;
  }
  return this.schema.path(path);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  this.$__.activePaths.init(path);
  delete this.$__.pathsToScopes[path];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return Object.keys(this.$__.activePaths.states.modify);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const isEmptyOptions = {
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  };

  if (arguments.length > 0) {
    const v = this.get(path);
    if (v == null) {
      return true;
    }
    if (typeof v !== 'object') {
      return false;
    }
    if (utils.isPOJO(v)) {
      return _isEmpty(v);
    }
    return Object.keys(v.toObject(isEmptyOptions)).length === 0;
  }

  return Object.keys(this.toObject(isEmptyOptions)).length === 0;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  options = options || {};
  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  const _this = this;
  return directModifiedPaths.reduce(function(list, path) {
    const parts = path.split('.');
    list = list.concat(parts.reduce(function(chains, part, i) {
      return chains.concat(parts.slice(0, i).concat(part).join('.'));
    }, []).filter(function(chain) {
      return (list.indexOf(chain) === -1);
    }));

    if (!options.includeChildren) {
      return list;
    }

    let cur = _this.get(path);
    if (cur != null && typeof cur === 'object') {
      if (cur._doc) {
        cur = cur._doc;
      }
      if (Array.isArray(cur)) {
        const len = cur.length;
        for (let i = 0; i < len; ++i) {
          if (list.indexOf(path + '.' + i) === -1) {
            list.push(path + '.' + i);
            if (cur[i] != null && cur[i].$__) {
              const modified = cur[i].modifiedPaths();
              for (const childPath of modified) {
                list.push(path + '.' + i + '.' + childPath);
              }
            }
          }
        }
      } else {
        Object.keys(cur).
          filter(function(key) {
            return list.indexOf(path + '.' + key) === -1;
          }).
          forEach(function(key) {
            list.push(path + '.' + key);
          });
      }
    }

    return list;
  }, []);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(paths, modifiedPaths) {
  if (paths) {
    if (!Array.isArray(paths)) {
      paths = paths.split(' ');
    }
    const modified = modifiedPaths || this[documentModifiedPaths]();
    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
    const isModifiedChild = paths.some(function(path) {
      return !!~modified.indexOf(path);
    });

    return isModifiedChild || paths.some(function(path) {
      return directModifiedPaths.some(function(mod) {
        return mod === path || path.startsWith(mod + '.');
      });
    });
  }

  return this.$__.activePaths.some('modify');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('default');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.default.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(val) {
  if (arguments.length === 0) {
    return !!this.$__.isDeleted;
  }

  this.$__.isDeleted = !!val;
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('modify');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.modify.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('init');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.init.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__isSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (path in this.$__.selected) {
    return inclusive;
  }

  const pathDot = path + '.';

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }

    if (cur.startsWith(pathDot)) {
      return inclusive || cur !== pathDot;
    }

    if (pathDot.startsWith(cur + '.')) {
      return inclusive;
    }
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__isSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (path in this.$__.selected) {
    return inclusive;
  }

  const pathDot = path + '.';

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }

    if (cur.startsWith(pathDot)) {
      return inclusive || cur !== pathDot;
    }

    if (pathDot.startsWith(cur + '.')) {
      return inclusive;
    }
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isDirectSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.isDirectSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (this.$__.selected.hasOwnProperty(path)) {
    return inclusive;
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options, callback) {
  let parallelValidate;
  this.$op = 'validate';

  if (this.ownerDocument != null) {
    // Skip parallel validate check for subdocuments
  } else if (this.$__.validating) {
    parallelValidate = new ParallelValidateError(this, {
      parentStack: options && options.parentStack,
      conflictStack: this.$__.validating.stack
    });
  } else {
    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
  }

  if (typeof pathsToValidate === 'function') {
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = pathsToValidate;
    pathsToValidate = null;
  }

  return promiseOrCallback(callback, cb => {
    if (parallelValidate != null) {
      return cb(parallelValidate);
    }

    this.$__validate(pathsToValidate, options, (error) => {
      this.$op = null;
      cb(error);
    });
  }, this.constructor.events);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options) {
  const _this = this;

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }

  if (typeof pathsToValidate === 'string') {
    pathsToValidate = pathsToValidate.split(' ');
  }

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];

  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  }
  const validating = {};

  paths.forEach(function(path) {
    if (validating[path]) {
      return;
    }

    validating[path] = true;

    const p = _this.schema.path(path);
    if (!p) {
      return;
    }
    if (!_this.$isValid(path)) {
      return;
    }

    const val = _this.$__getValue(path);
    const err = p.doValidateSync(val, _this, {
      skipSchemaValidators: skipSchemaValidators[path],
      path: path
    });
    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
      if (p.$isSingleNested &&
          err instanceof ValidationError &&
          p.schema.options.storeSubdocValidationError === false) {
        return;
      }
      _this.invalidate(path, err, undefined, true);
    }
  });

  const err = _this.$__.validationError;
  _this.$__.validationError = undefined;
  _this.emit('validate', _this);
  _this.constructor.emit('validate', _this);

  if (err) {
    for (const key in err.errors) {
      // Make sure cast errors persist
      if (err.errors[key] instanceof MongooseError.CastError) {
        _this.invalidate(key, err.errors[key]);
      }
    }
  }

  return err;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function reset() {
  let _this = this;
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  this.$__.activePaths
    .map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    })
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    })
    .forEach(function(array) {
      let i = array.length;
      while (i--) {
        const doc = array[i];
        if (!doc) {
          continue;
        }
        doc.$__reset();
      }

      _this.$__.activePaths.init(array.$path());

      array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
      array[arrayAtomicsSymbol] = {};
    });

  this.$__.activePaths.
    map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    }).
    filter(function(val) {
      return val && val.$isSingleNested;
    }).
    forEach(function(doc) {
      doc.$__reset();
      _this.$__.activePaths.init(doc.$basePath);
    });

  // clear atomics
  this.$__dirty().forEach(function(dirt) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol]) {
      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
      type[arrayAtomicsSymbol] = {};
    }
  });

  this.$__.backup = {};
  this.$__.backup.activePaths = {
    modify: Object.assign({}, this.$__.activePaths.states.modify),
    default: Object.assign({}, this.$__.activePaths.states.default)
  };
  this.$__.backup.validationError = this.$__.validationError;
  this.$__.backup.errors = this.errors;

  // Clear 'dirty' cache
  this.$__.activePaths.clear('modify');
  this.$__.activePaths.clear('default');
  this.$__.validationError = undefined;
  this.errors = undefined;
  _this = this;
  this.schema.requiredPaths().forEach(function(path) {
    _this.$__.activePaths.require(path);
  });

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $__undoReset() {
  if (this.$__.backup == null || this.$__.backup.activePaths == null) {
    return;
  }

  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;

  this.$__.validationError = this.$__.backup.validationError;
  this.errors = this.$__.backup.errors;

  for (const dirt of this.$__dirty()) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
    }
  }

  for (const subdoc of this.$__getAllSubdocs()) {
    subdoc.$__undoReset();
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const _this = this;

  let all = this.$__.activePaths.map('modify', function(path) {
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  });

  // gh-2558: if we had to set a default and the value is not undefined,
  // we have to save as well
  all = all.concat(this.$__.activePaths.map('default', function(path) {
    if (path === '_id' || _this.$__getValue(path) == null) {
      return;
    }
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  }));

  // Sort dirty paths in a flat hierarchy.
  all.sort(function(a, b) {
    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
  });

  // Ignore "foo.a" if "foo" is dirty already.
  const minimal = [];
  let lastPath;
  let top;

  all.forEach(function(item) {
    if (!item) {
      return;
    }
    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {
      lastPath = item.path + '.';
      minimal.push(item);
      top = item;
    } else if (top != null &&
        top.value != null &&
        top.value[arrayAtomicsSymbol] != null &&
        top.value.hasAtomics()) {
      // special case for top level MongooseArrays
      // the `top` array itself and a sub path of `top` are being modified.
      // the only way to honor all of both modifications is through a $set
      // of entire array.
      top.value[arrayAtomicsSymbol] = {};
      top.value[arrayAtomicsSymbol].$set = top.value;
    }
  });

  top = lastPath = null;
  return minimal;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(schema) {
  schema.plugin(idGetter, { deduplicate: true });
  compile(schema.tree, this, undefined, schema.options);

  // Apply default getters if virtual doesn't have any (gh-6262)
  for (const key of Object.keys(schema.virtuals)) {
    schema.virtuals[key]._applyDefaultGetters();
  }

  this.schema = schema;
  this[documentSchemaSymbol] = schema;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  // validate all document arrays.
  return this.$__.activePaths
    .map('init', 'modify', function(i) {
      return this.$__getValue(i);
    }.bind(this))
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    }).reduce(function(seed, array) {
      return seed.concat(array);
    }, [])
    .filter(function(doc) {
      return doc;
    });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));
  Embedded = Embedded || require('./types/embedded');

  function docReducer(doc, seed, path) {
    let val = doc;
    if (path) {
      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
        val = doc._doc[path];
      } else {
        val = doc[path];
      }
    }
    if (val instanceof Embedded) {
      seed.push(val);
    } else if (val instanceof Map) {
      seed = Array.from(val.keys()).reduce(function(seed, path) {
        return docReducer(val.get(path), seed, null);
      }, seed);
    } else if (val && val.$isSingleNested) {
      seed = Object.keys(val._doc).reduce(function(seed, path) {
        return docReducer(val._doc, seed, path);
      }, seed);
      seed.push(val);
    } else if (val && val.isMongooseDocumentArray) {
      val.forEach(function _docReduce(doc) {
        if (!doc || !doc._doc) {
          return;
        }
        seed = Object.keys(doc._doc).reduce(function(seed, path) {
          return docReducer(doc._doc, seed, path);
        }, seed);
        if (doc instanceof Embedded) {
          seed.push(doc);
        }
      });
    } else if (val instanceof Document && val.$__isNested) {
      seed = Object.keys(val).reduce(function(seed, path) {
        return docReducer(val, seed, path);
      }, seed);
    }
    return seed;
  }

  const _this = this;
  const subDocs = Object.keys(this._doc).reduce(function(seed, path) {
    return docReducer(_this, seed, path);
  }, []);

  return subDocs;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function handleReject(err) {
  // emit on the Model if listening
  if (this.listeners('error').length) {
    this.emit('error', err);
  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {
    this.constructor.emit('error', err);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, json) {
  let defaultOptions = {
    transform: true,
    flattenDecimals: true
  };

  const path = json ? 'toJSON' : 'toObject';
  const baseOptions = get(this, 'constructor.base.options.' + path, {});
  const schemaOptions = get(this, 'schema.options', {});
  // merge base default options with Schema's set default options if available.
  // `clone` is necessary here because `utils.options` directly modifies the second input.
  defaultOptions = utils.options(defaultOptions, clone(baseOptions));
  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));

  // If options do not exist or is not an object, set it to empty object
  options = utils.isPOJO(options) ? clone(options) : {};
  options._calledWithOptions = options._calledWithOptions || clone(options);

  if (!('flattenMaps' in options)) {
    options.flattenMaps = defaultOptions.flattenMaps;
  }

  let _minimize;
  if (options._calledWithOptions.minimize != null) {
    _minimize = options.minimize;
  } else if (defaultOptions.minimize != null) {
    _minimize = defaultOptions.minimize;
  } else {
    _minimize = schemaOptions.minimize;
  }

  // The original options that will be passed to `clone()`. Important because
  // `clone()` will recursively call `$toObject()` on embedded docs, so we
  // need the original options the user passed in, plus `_isNested` and
  // `_parentOptions` for checking whether we need to depopulate.
  const cloneOptions = Object.assign(utils.clone(options), {
    _isNested: true,
    json: json,
    minimize: _minimize
  });

  if (utils.hasUserDefinedProperty(options, 'getters')) {
    cloneOptions.getters = options.getters;
  }
  if (utils.hasUserDefinedProperty(options, 'virtuals')) {
    cloneOptions.virtuals = options.virtuals;
  }

  const depopulate = options.depopulate ||
    get(options, '_parentOptions.depopulate', false);
  // _isNested will only be true if this is not the top level document, we
  // should never depopulate
  if (depopulate && options._isNested && this.$__.wasPopulated) {
    // populated paths that we set to a document
    return clone(this._id, cloneOptions);
  }

  // merge default options with input options.
  options = utils.options(defaultOptions, options);
  options._isNested = true;
  options.json = json;
  options.minimize = _minimize;

  cloneOptions._parentOptions = options;
  cloneOptions._skipSingleNestedGetters = true;

  const gettersOptions = Object.assign({}, cloneOptions);
  gettersOptions._skipSingleNestedGetters = false;

  // remember the root transform function
  // to save it from being overwritten by sub-transform functions
  const originalTransform = options.transform;

  let ret = clone(this._doc, cloneOptions) || {};

  if (options.getters) {
    applyGetters(this, ret, gettersOptions);

    if (options.minimize) {
      ret = minimize(ret) || {};
    }
  }

  if (options.virtuals || (options.getters && options.virtuals !== false)) {
    applyVirtuals(this, ret, gettersOptions, options);
  }

  if (options.versionKey === false && this.schema.options.versionKey) {
    delete ret[this.schema.options.versionKey];
  }

  let transform = options.transform;

  // In the case where a subdocument has its own transform function, we need to
  // check and see if the parent has a transform (options.transform) and if the
  // child schema has a transform (this.schema.options.toObject) In this case,
  // we need to adjust options.transform to be the child schema's transform and
  // not the parent schema's
  if (transform) {
    applySchemaTypeTransforms(this, ret);
  }

  if (options.useProjection) {
    omitDeselectedFields(this, ret);
  }

  if (transform === true || (schemaOptions.toObject && transform)) {
    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;

    if (opts) {
      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
    }
  } else {
    options.transform = originalTransform;
  }

  if (typeof transform === 'function') {
    const xformed = transform(this, ret, options);
    if (typeof xformed !== 'undefined') {
      ret = xformed;
    }
  }

  return ret;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  return this.$toObject(options);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  return this.$toObject(options, true);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const ret = this.inspect();
  if (typeof ret === 'string') {
    return ret;
  }
  return inspect(ret);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(doc) {
  if (!doc) {
    return false;
  }

  const tid = this.$__getValue('_id');
  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;
  if (!tid && !docid) {
    return deepEqual(this, doc);
  }
  return tid && tid.equals
    ? tid.equals(docid)
    : tid === docid;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(callback) {
  const isUsingShorthand = callback != null && typeof callback !== 'function';
  if (isUsingShorthand) {
    return this.populate.apply(this, arguments).execPopulate();
  }

  return promiseOrCallback(callback, cb => {
    this.populate(cb);
  }, this.constructor.events);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, val, options) {
  // val and options are internal
  if (val === null || val === void 0) {
    if (!this.$__.populated) {
      return undefined;
    }
    const v = this.$__.populated[path];
    if (v) {
      return v.value;
    }
    return undefined;
  }

  // internal
  if (val === true) {
    if (!this.$__.populated) {
      return undefined;
    }
    return this.$__.populated[path];
  }

  this.$__.populated || (this.$__.populated = {});
  this.$__.populated[path] = { value: val, options: options };

  // If this was a nested populate, make sure each populated doc knows
  // about its populated children (gh-7685)
  const pieces = path.split('.');
  for (let i = 0; i < pieces.length - 1; ++i) {
    const subpath = pieces.slice(0, i + 1).join('.');
    const subdoc = this.get(subpath);
    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
      const rest = pieces.slice(i + 1).join('.');
      subdoc.populated(rest, val, options);
      // No need to continue because the above recursion should take care of
      // marking the rest of the docs as populated
      break;
    }
  }

  return val;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (typeof path === 'string') {
    path = path.split(' ');
  }

  let populatedIds;
  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
  const populated = get(this, '$__.populated', {});

  if (arguments.length === 0) {
    // Depopulate all
    for (const virtualKey of virtualKeys) {
      delete this.$$populatedVirtuals[virtualKey];
      delete this._doc[virtualKey];
      delete populated[virtualKey];
    }

    const keys = Object.keys(populated);

    for (const key of keys) {
      populatedIds = this.populated(key);
      if (!populatedIds) {
        continue;
      }
      delete populated[key];
      this.$set(key, populatedIds);
    }
    return this;
  }

  for (const singlePath of path) {
    populatedIds = this.populated(singlePath);
    delete populated[singlePath];

    if (virtualKeys.indexOf(singlePath) !== -1) {
      delete this.$$populatedVirtuals[singlePath];
      delete this._doc[singlePath];
    } else if (populatedIds) {
      this.$set(singlePath, populatedIds);
    }
  }
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const delta = this.$__delta();
  const changes = delta ? delta[1] : {};
  return changes;
}
                                              </td>
                                              
                                          </tr>
                                          
                                          <tr>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  {
  _id: 60735418b255ff0b80680324,
  questionId: 15,
  question: 'What is formal testing?',
  answer: 'Verification of software, according to the test plan, test procedures and relevant documentation, taking into account the wishes of the client',
  rightAnswer: false
},{
  _id: 60735418b255ff0b80680325,
  questionId: 8,
  question: "Agile's main ideas",
  answer: 'All options are incorrect',
  rightAnswer: false
},{
  _id: 60735418b255ff0b80680326,
  questionId: 22,
  question: 'This is a comprehensive user testing of concurrent access to an application to verify the impact on a code, module or database. Mainly detects deadlocks in code.',
  answer: 'Currency testing',
  rightAnswer: true
},{
  _id: 60735418b255ff0b80680327,
  questionId: 18,
  question: 'Which of the following is superfluous',
  answer: 'Check list',
  rightAnswer: false
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  3
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  true
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  false
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  18
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  Which of the following is superfluous
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  Check list
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  false
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  60735418b255ff0b80680327
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  60735418b255ff0b80680327
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  [object Object]
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function EmbeddedDocument() {
    Subdocument.apply(this, arguments);

    this.$session(this.ownerDocument().$session());
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  questions
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options, callback) {
  if (typeof pathsToValidate === 'function') {
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }

  const _this = this;
  const _complete = () => {
    let validationError = this.$__.validationError;
    this.$__.validationError = undefined;

    if (shouldValidateModifiedOnly && validationError != null) {
      // Remove any validation errors that aren't from modified paths
      const errors = Object.keys(validationError.errors);
      for (const errPath of errors) {
        if (!this.isModified(errPath)) {
          delete validationError.errors[errPath];
        }
      }
      if (Object.keys(validationError.errors).length === 0) {
        validationError = void 0;
      }
    }

    this.$__.cachedRequired = {};
    this.emit('validate', _this);
    this.constructor.emit('validate', _this);

    this.$__.validating = null;
    if (validationError) {
      for (const key in validationError.errors) {
        // Make sure cast errors persist
        if (!this[documentArrayParent] &&
            validationError.errors[key] instanceof MongooseError.CastError) {
          this.invalidate(key, validationError.errors[key]);
        }
      }

      return validationError;
    }
  };

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];
  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  }
  if (paths.length === 0) {
    return process.nextTick(function() {
      const error = _complete();
      if (error) {
        return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
          callback(error);
        });
      }
      callback(null, _this);
    });
  }

  const validated = {};
  let total = 0;

  const complete = function() {
    const error = _complete();
    if (error) {
      return _this.schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
        callback(error);
      });
    }
    callback(null, _this);
  };

  const validatePath = function(path) {
    if (path == null || validated[path]) {
      return;
    }

    validated[path] = true;
    total++;

    process.nextTick(function() {
      const schemaType = _this.schema.path(path);

      if (!schemaType) {
        return --total || complete();
      }

      // If user marked as invalid or there was a cast error, don't validate
      if (!_this.$isValid(path)) {
        --total || complete();
        return;
      }

      let val = _this.$__getValue(path);

      // If you `populate()` and get back a null value, required validators
      // shouldn't fail (gh-8018). We should always fall back to the populated
      // value.
      let pop;
      if (val == null && (pop = _this.populated(path))) {
        val = pop;
      }
      const scope = path in _this.$__.pathsToScopes ?
        _this.$__.pathsToScopes[path] :
        _this;

      const doValidateOptions = {
        skipSchemaValidators: skipSchemaValidators[path],
        path: path
      };
      schemaType.doValidate(val, function(err) {
        if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
          if (schemaType.$isSingleNested &&
              err instanceof ValidationError &&
              schemaType.schema.options.storeSubdocValidationError === false) {
            return --total || complete();
          }
          _this.invalidate(path, err, undefined, true);
        }
        --total || complete();
      }, scope, doValidateOptions);
    });
  };

  const numPaths = paths.length;
  for (let i = 0; i < numPaths; ++i) {
    validatePath(paths[i]);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
    var _context = context || this;
    var args = Array.prototype.slice.call(arguments);
    _this.wrap(name, fn, _context, args, options);
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      process.nextTick(() => fn.apply(this, arguments));
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
    var _context = context || this;
    var args = Array.prototype.slice.call(arguments);
    _this.wrap(name, fn, _context, args, options);
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      process.nextTick(() => fn.apply(this, arguments));
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function syncWrapper() {
    kareem.execPreSync(name, this, arguments);

    var toReturn = fn.apply(this, arguments);

    kareem.execPostSync(name, this, [toReturn]);

    return toReturn;
  }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.toObject(internalToObjectOptions);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(index) {
  this.__index = index;

  if (get(this, '$__.validationError', null) != null) {
    const keys = Object.keys(this.$__.validationError.errors);
    for (const key of keys) {
      this.invalidate(key, this.$__.validationError.errors[key]);
    }
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  this.$__.activePaths.modify(path);
  if (!this.__parentArray) {
    return;
  }

  const pathToCheck = this.__parentArray.$path() + '.0.' + path;
  if (this.isNew && this.ownerDocument().$__isSelected(pathToCheck)) {
    // Mark the WHOLE parent array as modified
    // if this is a new document (i.e., we are initializing
    // a document),
    this.__parentArray._markModified();
  } else {
    this.__parentArray._markModified(this, path);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  throw new Error('Mongoose does not support calling populate() on nested ' +
    'docs. Instead of `doc.arr[0].populate("path")`, use ' +
    '`doc.populate("arr.0.path")`');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = {};
  }
  options = options || {};

  if (!options.suppressWarning) {
    console.warn('mongoose: calling `save()` on a subdoc does **not** save ' +
      'the document to MongoDB, it only runs save middleware. ' +
      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +
      'if you\'re sure this behavior is right for your app.');
  }

  return promiseOrCallback(fn, cb => {
    this.$__save(cb);
  });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, fn) {
  if (typeof options === 'function' && !fn) {
    fn = options;
    options = undefined;
  }
  if (!this.__parentArray || (options && options.noop)) {
    this.$__remove(fn);
    return this;
  }

  let _id;
  if (!this.willRemove) {
    _id = this._doc._id;
    if (!_id) {
      throw new Error('For your own good, Mongoose does not know ' +
          'how to remove an EmbeddedDocument that has no _id');
    }
    this.__parentArray.pull({ _id: _id });
    this.willRemove = true;
    registerRemoveListener(this);
  }

  this.$__remove(fn);

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  throw new Error('The #update method is not available on EmbeddedDocuments');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.toObject({
    transform: false,
    virtuals: false,
    flattenDecimals: false
  });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, err, val) {
  Document.prototype.invalidate.call(this, path, err, val);

  if (!this[documentArrayParent] || this.__index == null) {
    if (err[validatorErrorSymbol] || err instanceof ValidationError) {
      return this.ownerDocument().$__.validationError;
    }
    throw err;
  }

  const index = this.__index;
  const parentPath = this.__parentArray.$path();
  const fullPath = [parentPath, index, path].join('.');
  this[documentArrayParent].invalidate(fullPath, err, val);

  return this.ownerDocument().$__.validationError;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (!this[documentArrayParent]) {
    return;
  }

  const index = this.__index;
  if (typeof index !== 'undefined') {
    const parentPath = this.__parentArray.$path();
    const fullPath = [parentPath, index, path].join('.');
    this[documentArrayParent].$markValid(fullPath);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  Document.prototype.$ignore.call(this, path);

  if (!this[documentArrayParent]) {
    return;
  }

  const index = this.__index;
  if (typeof index !== 'undefined') {
    const parentPath = this.__parentArray.$path();
    const fullPath = [parentPath, index, path].join('.');
    this[documentArrayParent].$ignore(fullPath);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const index = this.__index;
  if (typeof index !== 'undefined' && this[documentArrayParent]) {
    return !this[documentArrayParent].$__.validationError ||
      !this[documentArrayParent].$__.validationError.errors[this.$__fullPath(path)];
  }

  return true;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  if (this.$__.ownerDocument) {
    return this.$__.ownerDocument;
  }

  let parent = this[documentArrayParent];
  if (!parent) {
    return this;
  }

  while (parent[documentArrayParent] || parent.$__parent) {
    parent = parent[documentArrayParent] || parent.$__parent;
  }

  this.$__.ownerDocument = parent;
  return this.$__.ownerDocument;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (!this.$__.fullPath) {
    let parent = this; // eslint-disable-line consistent-this
    if (!parent[documentArrayParent]) {
      return path;
    }

    const paths = [];
    while (parent[documentArrayParent] || parent.$__parent) {
      if (parent[documentArrayParent]) {
        paths.unshift(parent.__parentArray.$path());
      } else {
        paths.unshift(parent.$basePath);
      }
      parent = parent[documentArrayParent] || parent.$__parent;
    }

    this.$__.fullPath = paths.join('.');

    if (!this.$__.ownerDocument) {
      // optimization
      this.$__.ownerDocument = parent;
    }
  }

  return path
    ? this.$__.fullPath + '.' + path
    : this.$__.fullPath;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this[documentArrayParent];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this[documentArrayParent];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return this.__parentArray;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    }
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(obj, fields, skipId, exclude, hasIncludedChildren) {
  const doc = {};

  const paths = Object.keys(this.schema.paths).
    // Don't build up any paths that are underneath a map, we don't know
    // what the keys will be
    filter(p => !p.includes('$*'));
  const plen = paths.length;
  let ii = 0;

  for (; ii < plen; ++ii) {
    const p = paths[ii];

    if (p === '_id') {
      if (skipId) {
        continue;
      }
      if (obj && '_id' in obj) {
        continue;
      }
    }

    const path = p.split('.');
    const len = path.length;
    const last = len - 1;
    let curPath = '';
    let doc_ = doc;
    let included = false;

    for (let i = 0; i < len; ++i) {
      const piece = path[i];

      curPath += (!curPath.length ? '' : '.') + piece;

      // support excluding intermediary levels
      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }

      if (i < last) {
        doc_ = doc_[piece] || (doc_[piece] = {});
      }
    }
  }

  this._doc = doc;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(doc, opts, fn) {
  if (typeof opts === 'function') {
    fn = opts;
    opts = null;
  }

  this.$__init(doc, opts);

  if (fn) {
    fn(null, this);
  }

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function updateOne(doc, options, callback) {
  const query = this.constructor.updateOne({ _id: this._id }, doc, options);
  query._pre(cb => {
    this.constructor._middleware.execPre('updateOne', this, [this], cb);
  });
  query._post(cb => {
    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);
  });

  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }

  if (callback != null) {
    return query.exec(callback);
  }

  return query;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function replaceOne() {
  const args = utils.args(arguments);
  args.unshift({ _id: this._id });
  return this.constructor.replaceOne.apply(this.constructor, args);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $session(session) {
  if (arguments.length === 0) {
    return this.$__.session;
  }
  this.$__.session = session;

  if (!this.ownerDocument) {
    const subdocs = this.$__getAllSubdocs();
    for (const child of subdocs) {
      child.$session(session);
    }
  }

  return session;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function overwrite(obj) {
  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));

  for (const key of keys) {
    if (key === '_id') {
      continue;
    }
    // Explicitly skip version key
    if (this.schema.options.versionKey && key === this.schema.options.versionKey) {
      continue;
    }
    if (this.schema.options.discriminatorKey && key === this.schema.options.discriminatorKey) {
      continue;
    }
    this.$set(key, obj[key]);
  }

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $set(path, val, type, options) {

  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }

  if (path == null) {
    const _ = path;
    path = val;
    val = _;
  } else if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path instanceof Document) {
      if (path.$__isNested) {
        path = path.toObject();
      } else {
        path = path._doc;
      }
    }
    if (path == null) {
      const _ = path;
      path = val;
      val = _;
    }

    prefix = val ? val + '.' : '';
    keys = Object.keys(path);
    const len = keys.length;

    // `_skipMinimizeTopLevel` is because we may have deleted the top-level
    // nested key to ensure key order.
    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);
    if (len === 0 && _skipMinimizeTopLevel) {
      delete options._skipMinimizeTopLevel;
      if (val) {
        this.$set(val, {});
      }
      return this;
    }

    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix + key;
      pathtype = this.schema.pathType(pathName);

      // On initial set, delete any nested keys if we're going to overwrite
      // them to ensure we keep the user's key order.
      if (type === true &&
          !prefix &&
          path[key] != null &&
          pathtype === 'nested' &&
          this._doc[key] != null &&
          Object.keys(this._doc[key]).length === 0) {
        delete this._doc[key];
        // Make sure we set `{}` back even if we minimize re: gh-8565
        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
      }

      const someCondition = typeof path[key] === 'object' &&
                            !utils.isNativeObject(path[key]) &&
                            !utils.isMongooseType(path[key]) &&
                            path[key] != null &&
                            pathtype !== 'virtual' &&
                            pathtype !== 'real' &&
                            pathtype !== 'adhocOrUndefined' &&
                            !(this.$__path(pathName) instanceof MixedSchema) &&
                            !(this.schema.paths[pathName] &&
                            this.schema.paths[pathName].options &&
                            this.schema.paths[pathName].options.ref);

      if (someCondition) {
        this.$__.$setCalled.add(prefix + key);
        this.$set(path[key], prefix + key, constructing, options);
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && path[key] === void 0 &&
            this.get(pathName) !== void 0) {
          continue;
        }

        if (pathtype === 'adhocOrUndefined') {
          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
        }

        if (pathtype === 'real' || pathtype === 'virtual') {
          // Check for setting single embedded schema to document (gh-3535)
          let p = path[key];
          if (this.schema.paths[pathName] &&
              this.schema.paths[pathName].$isSingleNested &&
              path[key] instanceof Document) {
            p = p.toObject({ virtuals: false, transform: false });
          }
          this.$set(prefix + key, p, constructing, options);
        } else if (pathtype === 'nested' && path[key] instanceof Document) {
          this.$set(prefix + key,
            path[key].toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, path[key]);
          } else {
            throw new StrictModeError(key);
          }
        }
      } else if (path[key] !== void 0) {
        this.$set(prefix + key, path[key], constructing, options);
      }
    }

    return this;
  } else {
    this.$__.$setCalled.add(path);
  }

  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
  val = handleSpreadDoc(val);

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const priorVal = this.$__getValue(path);
        this.$__.savedState[path] = priorVal;

        const keys = Object.keys(priorVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = priorVal[key];
        }
      }

      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }

      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {
        this.unmarkModified(path);
      } else {
        this.markModified(path);
      }
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.$__isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) { pathtomark="path;" } else for (i="0;" i < parts.length; ++i) const subpath="parts.slice(0," + 1).join('.'); if (this.get(subpath, null, getters: false })="==" null) break; (!pathtomark) this doc is being constructed we should not trigger getters priorval="(()" => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }

  // If overwriting a subdocument path, make sure to clear out
  // any errors _before_ setting, so new errors that happen
  // get persisted. Re: #9080
  if (schema.$isSingleNested || schema.$isMongooseArray) {
    _markValidSubpaths(this, path);
  }

  if (schema.$isSingleNested && val != null && merge) {
    if (val instanceof Document) {
      val = val.toObject({ virtuals: false, transform: false });
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      this.$set(path + '.' + key, val[key], constructing, options);
    }

    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      return modelName === model.modelName || modelName === model.baseModelName;
    })();

    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = true;
      didPopulate = true;
    }

    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      for (const doc of val) {
        doc.$__.wasPopulated = true;
      }
      didPopulate = true;
    }

    if (this.schema.singleNestedPaths[path] == null) {
      // If this path is underneath a single nested schema, we'll call the setter
      // later in `$__set()` because we don't take `_doc` when we iterate through
      // a single nested doc. That's to make sure we get the correct context.
      // Otherwise we would double-call the setter, see gh-7196.
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (schema.$isMongooseDocumentArray &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] != null &&
        val[0].$__ != null &&
        val[0].$__.populated != null) {
      const populatedPaths = Object.keys(val[0].$__.populated);
      for (const populatedPath of populatedPaths) {
        this.populated(path + '.' + populatedPath,
          val.map(v => v.populated(populatedPath)),
          val[0].$__.populated[populatedPath].options);
      }
      didPopulate = true;
    }

    if (!didPopulate && this.$__.populated) {
      // If this array partially contains populated documents, convert them
      // all to ObjectIds re: #8443
      if (Array.isArray(val) && this.$__.populated[path]) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] instanceof Document) {
            val[i] = val[i]._id;
          }
        }
      }
      delete this.$__.populated[path];
    }

    if (schema.$isSingleNested && val != null) {
      _checkImmutableSubpaths(val, schema, priorVal);
    }

    this.$markValid(path);
  } catch (e) {
    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
      this.invalidate(path, e);
    } else if (e instanceof MongooseError.CastError) {
      this.invalidate(e.path, e);
      if (e.$originalErrorPath) {
        this.invalidate(path,
          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
      }
    } else {
      this.invalidate(path,
        new MongooseError.CastError(schema.instance, val, path, e));
    }
    shouldSet = false;
  }

  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);

    if (this.$__.savedState != null) {
      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        this.$__.savedState[path] = priorVal;
      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {
        this.unmarkModified(path);
      }
    }
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
}
                                              </=></td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $set(path, val, type, options) {

  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

  const strict = 'strict' in options
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.schema.interpretAsType(path, type, this.schema.options);
  }

  if (path == null) {
    const _ = path;
    path = val;
    val = _;
  } else if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path instanceof Document) {
      if (path.$__isNested) {
        path = path.toObject();
      } else {
        path = path._doc;
      }
    }
    if (path == null) {
      const _ = path;
      path = val;
      val = _;
    }

    prefix = val ? val + '.' : '';
    keys = Object.keys(path);
    const len = keys.length;

    // `_skipMinimizeTopLevel` is because we may have deleted the top-level
    // nested key to ensure key order.
    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);
    if (len === 0 && _skipMinimizeTopLevel) {
      delete options._skipMinimizeTopLevel;
      if (val) {
        this.$set(val, {});
      }
      return this;
    }

    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix + key;
      pathtype = this.schema.pathType(pathName);

      // On initial set, delete any nested keys if we're going to overwrite
      // them to ensure we keep the user's key order.
      if (type === true &&
          !prefix &&
          path[key] != null &&
          pathtype === 'nested' &&
          this._doc[key] != null &&
          Object.keys(this._doc[key]).length === 0) {
        delete this._doc[key];
        // Make sure we set `{}` back even if we minimize re: gh-8565
        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
      }

      const someCondition = typeof path[key] === 'object' &&
                            !utils.isNativeObject(path[key]) &&
                            !utils.isMongooseType(path[key]) &&
                            path[key] != null &&
                            pathtype !== 'virtual' &&
                            pathtype !== 'real' &&
                            pathtype !== 'adhocOrUndefined' &&
                            !(this.$__path(pathName) instanceof MixedSchema) &&
                            !(this.schema.paths[pathName] &&
                            this.schema.paths[pathName].options &&
                            this.schema.paths[pathName].options.ref);

      if (someCondition) {
        this.$__.$setCalled.add(prefix + key);
        this.$set(path[key], prefix + key, constructing, options);
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && path[key] === void 0 &&
            this.get(pathName) !== void 0) {
          continue;
        }

        if (pathtype === 'adhocOrUndefined') {
          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
        }

        if (pathtype === 'real' || pathtype === 'virtual') {
          // Check for setting single embedded schema to document (gh-3535)
          let p = path[key];
          if (this.schema.paths[pathName] &&
              this.schema.paths[pathName].$isSingleNested &&
              path[key] instanceof Document) {
            p = p.toObject({ virtuals: false, transform: false });
          }
          this.$set(prefix + key, p, constructing, options);
        } else if (pathtype === 'nested' && path[key] instanceof Document) {
          this.$set(prefix + key,
            path[key].toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, path[key]);
          } else {
            throw new StrictModeError(key);
          }
        }
      } else if (path[key] !== void 0) {
        this.$set(prefix + key, path[key], constructing, options);
      }
    }

    return this;
  } else {
    this.$__.$setCalled.add(path);
  }

  let pathType = this.schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
  val = handleSpreadDoc(val);

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const priorVal = this.$__getValue(path);
        this.$__.savedState[path] = priorVal;

        const keys = Object.keys(priorVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = priorVal[key];
        }
      }

      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }

      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {
        this.unmarkModified(path);
      } else {
        this.markModified(path);
      }
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[parts[0]] == 'string') {
    parts[0] = this.schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.$__isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) { pathtomark="path;" } else for (i="0;" i < parts.length; ++i) const subpath="parts.slice(0," + 1).join('.'); if (this.get(subpath, null, getters: false })="==" null) break; (!pathtomark) this doc is being constructed we should not trigger getters priorval="(()" => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
    return this;
  }

  // If overwriting a subdocument path, make sure to clear out
  // any errors _before_ setting, so new errors that happen
  // get persisted. Re: #9080
  if (schema.$isSingleNested || schema.$isMongooseArray) {
    _markValidSubpaths(this, path);
  }

  if (schema.$isSingleNested && val != null && merge) {
    if (val instanceof Document) {
      val = val.toObject({ virtuals: false, transform: false });
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      this.$set(path + '.' + key, val[key], constructing, options);
    }

    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
      const ref = schema.options.ref;
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      return modelName === model.modelName || modelName === model.baseModelName;
    })();

    let didPopulate = false;
    if (refMatches && val instanceof Document) {
      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = true;
      didPopulate = true;
    }

    let popOpts;
    if (schema.options &&
        Array.isArray(schema.options[this.schema.options.typeKey]) &&
        schema.options[this.schema.options.typeKey].length &&
        schema.options[this.schema.options.typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[this.schema.options.typeKey][0].ref)) {
      if (this.ownerDocument) {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.ownerDocument().populated(this.$__fullPath(path),
          val.map(function(v) { return v._id; }), popOpts);
      } else {
        popOpts = { [populateModelSymbol]: val[0].constructor };
        this.populated(path, val.map(function(v) { return v._id; }), popOpts);
      }
      for (const doc of val) {
        doc.$__.wasPopulated = true;
      }
      didPopulate = true;
    }

    if (this.schema.singleNestedPaths[path] == null) {
      // If this path is underneath a single nested schema, we'll call the setter
      // later in `$__set()` because we don't take `_doc` when we iterate through
      // a single nested doc. That's to make sure we get the correct context.
      // Otherwise we would double-call the setter, see gh-7196.
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (schema.$isMongooseDocumentArray &&
        Array.isArray(val) &&
        val.length > 0 &&
        val[0] != null &&
        val[0].$__ != null &&
        val[0].$__.populated != null) {
      const populatedPaths = Object.keys(val[0].$__.populated);
      for (const populatedPath of populatedPaths) {
        this.populated(path + '.' + populatedPath,
          val.map(v => v.populated(populatedPath)),
          val[0].$__.populated[populatedPath].options);
      }
      didPopulate = true;
    }

    if (!didPopulate && this.$__.populated) {
      // If this array partially contains populated documents, convert them
      // all to ObjectIds re: #8443
      if (Array.isArray(val) && this.$__.populated[path]) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] instanceof Document) {
            val[i] = val[i]._id;
          }
        }
      }
      delete this.$__.populated[path];
    }

    if (schema.$isSingleNested && val != null) {
      _checkImmutableSubpaths(val, schema, priorVal);
    }

    this.$markValid(path);
  } catch (e) {
    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
      this.invalidate(path, e);
    } else if (e instanceof MongooseError.CastError) {
      this.invalidate(e.path, e);
      if (e.$originalErrorPath) {
        this.invalidate(path,
          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
      }
    } else {
      this.invalidate(path,
        new MongooseError.CastError(schema.instance, val, path, e));
    }
    shouldSet = false;
  }

  if (shouldSet) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);

    if (this.$__.savedState != null) {
      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        this.$__.savedState[path] = priorVal;
      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {
        this.unmarkModified(path);
      }
    }
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
}
                                              </=></td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  if (this.isNew) {
    return true;
  }

  // Re: the note about gh-7196, `val` is the raw value without casting or
  // setters if the full path is under a single nested subdoc because we don't
  // want to double run setters. So don't set it as modified. See gh-7264.
  if (this.schema.singleNestedPaths[path] != null) {
    return false;
  }

  if (val === void 0 && !this.$__isSelected(path)) {
    // when a path is not selected in a query, its initial
    // value will be undefined.
    return true;
  }

  if (val === void 0 && path in this.$__.activePaths.states.default) {
    // we're just unsetting the default value which was never saved
    return false;
  }

  // gh-3992: if setting a populated field to a doc, don't mark modified
  // if they have the same _id
  if (this.populated(path) &&
      val instanceof Document &&
      deepEqual(val._id, priorVal)) {
    return false;
  }

  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {
    return true;
  }

  if (!constructing &&
      val !== null &&
      val !== undefined &&
      path in this.$__.activePaths.states.default &&
      deepEqual(val, schema.getDefault(this, constructing))) {
    // a path with a default was $unset on the server
    // and the user is setting it to the same value again
    return true;
  }
  return false;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  Embedded = Embedded || require('./types/embedded');

  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
    schema, val, priorVal);
  const _this = this;

  if (shouldModify) {
    this.markModified(pathToMark);

    // handle directly setting arrays (gh-1126)
    MongooseArray || (MongooseArray = require('./types/array'));
    if (val && val.isMongooseArray) {
      val._registerAtomic('$set', val);

      // Update embedded document parent references (gh-5189)
      if (val.isMongooseDocumentArray) {
        val.forEach(function(item) {
          item && item.__parentArray && (item.__parentArray = val);
        });
      }

      // Small hack for gh-1638: if we're overwriting the entire array, ignore
      // paths that were modified before the array overwrite
      this.$__.activePaths.forEach(function(modifiedPath) {
        if (modifiedPath.startsWith(path + '.')) {
          _this.$__.activePaths.ignore(modifiedPath);
        }
      });
    }
  }

  let obj = this._doc;
  let i = 0;
  const l = parts.length;
  let cur = '';

  for (; i < l; i++) {
    const next = i + 1;
    const last = next === l;
    cur += (cur ? '.' + parts[i] : parts[i]);
    if (specialProperties.has(parts[i])) {
      return;
    }

    if (last) {
      if (obj instanceof Map) {
        obj.set(parts[i], val);
      } else {
        obj[parts[i]] = val;
      }
    } else {
      if (utils.isPOJO(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else {
        obj[parts[i]] = obj[parts[i]] || {};
        obj = obj[parts[i]];
      }
    }
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  return utils.getValue(path, this._doc);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, val) {
  utils.setValue(path, val, this._doc);
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, type, options) {
  let adhoc;
  options = options || {};
  if (type) {
    adhoc = this.schema.interpretAsType(path, type, this.schema.options);
  }

  let schema = this.$__path(path);
  if (schema == null) {
    schema = this.schema.virtualpath(path);
  }
  if (schema instanceof MixedSchema) {
    const virtual = this.schema.virtualpath(path);
    if (virtual != null) {
      schema = virtual;
    }
  }
  const pieces = path.split('.');
  let obj = this._doc;

  if (schema instanceof VirtualType) {
    return schema.applyGetters(void 0, this);
  }

  // Might need to change path for top-level alias
  if (typeof this.schema.aliases[pieces[0]] == 'string') {
    pieces[0] = this.schema.aliases[pieces[0]];
  }

  for (let i = 0, l = pieces.length; i < l; i++) {
    if (obj && obj._doc) {
      obj = obj._doc;
    }

    if (obj == null) {
      obj = void 0;
    } else if (obj instanceof Map) {
      obj = obj.get(pieces[i], { getters: false });
    } else if (i === l - 1) {
      obj = utils.getValue(pieces[i], obj);
    } else {
      obj = obj[pieces[i]];
    }
  }

  if (adhoc) {
    obj = adhoc.cast(obj);
  }

  if (schema != null && options.getters !== false) {
    obj = schema.applyGetters(obj, this);
  } else if (this.schema.nested[path] && options.virtuals) {
    // Might need to apply virtuals if this is a nested path
    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });
  }

  return obj;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const adhocs = this.$__.adhocPaths;
  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;

  if (adhocType) {
    return adhocType;
  }
  return this.schema.path(path);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  this.$__.activePaths.init(path);
  delete this.$__.pathsToScopes[path];
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  return Object.keys(this.$__.activePaths.states.modify);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  const isEmptyOptions = {
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  };

  if (arguments.length > 0) {
    const v = this.get(path);
    if (v == null) {
      return true;
    }
    if (typeof v !== 'object') {
      return false;
    }
    if (utils.isPOJO(v)) {
      return _isEmpty(v);
    }
    return Object.keys(v.toObject(isEmptyOptions)).length === 0;
  }

  return Object.keys(this.toObject(isEmptyOptions)).length === 0;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  options = options || {};
  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  const _this = this;
  return directModifiedPaths.reduce(function(list, path) {
    const parts = path.split('.');
    list = list.concat(parts.reduce(function(chains, part, i) {
      return chains.concat(parts.slice(0, i).concat(part).join('.'));
    }, []).filter(function(chain) {
      return (list.indexOf(chain) === -1);
    }));

    if (!options.includeChildren) {
      return list;
    }

    let cur = _this.get(path);
    if (cur != null && typeof cur === 'object') {
      if (cur._doc) {
        cur = cur._doc;
      }
      if (Array.isArray(cur)) {
        const len = cur.length;
        for (let i = 0; i < len; ++i) {
          if (list.indexOf(path + '.' + i) === -1) {
            list.push(path + '.' + i);
            if (cur[i] != null && cur[i].$__) {
              const modified = cur[i].modifiedPaths();
              for (const childPath of modified) {
                list.push(path + '.' + i + '.' + childPath);
              }
            }
          }
        }
      } else {
        Object.keys(cur).
          filter(function(key) {
            return list.indexOf(path + '.' + key) === -1;
          }).
          forEach(function(key) {
            list.push(path + '.' + key);
          });
      }
    }

    return list;
  }, []);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(paths, modifiedPaths) {
  if (paths) {
    if (!Array.isArray(paths)) {
      paths = paths.split(' ');
    }
    const modified = modifiedPaths || this[documentModifiedPaths]();
    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
    const isModifiedChild = paths.some(function(path) {
      return !!~modified.indexOf(path);
    });

    return isModifiedChild || paths.some(function(path) {
      return directModifiedPaths.some(function(mod) {
        return mod === path || path.startsWith(mod + '.');
      });
    });
  }

  return this.$__.activePaths.some('modify');
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('default');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.default.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(val) {
  if (arguments.length === 0) {
    return !!this.$__.isDeleted;
  }

  this.$__.isDeleted = !!val;
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('modify');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.modify.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (path == null) {
    return this.$__.activePaths.some('init');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
    return this.$__.activePaths.states.init.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__isSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (path in this.$__.selected) {
    return inclusive;
  }

  const pathDot = path + '.';

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }

    if (cur.startsWith(pathDot)) {
      return inclusive || cur !== pathDot;
    }

    if (pathDot.startsWith(cur + '.')) {
      return inclusive;
    }
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__isSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (path in this.$__.selected) {
    return inclusive;
  }

  const pathDot = path + '.';

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }

    if (cur.startsWith(pathDot)) {
      return inclusive || cur !== pathDot;
    }

    if (pathDot.startsWith(cur + '.')) {
      return inclusive;
    }
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function isDirectSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.isDirectSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (this.$__.selected.hasOwnProperty(path)) {
    return inclusive;
  }

  return !inclusive;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options, callback) {
  let parallelValidate;
  this.$op = 'validate';

  if (this.ownerDocument != null) {
    // Skip parallel validate check for subdocuments
  } else if (this.$__.validating) {
    parallelValidate = new ParallelValidateError(this, {
      parentStack: options && options.parentStack,
      conflictStack: this.$__.validating.stack
    });
  } else {
    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
  }

  if (typeof pathsToValidate === 'function') {
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = pathsToValidate;
    pathsToValidate = null;
  }

  return promiseOrCallback(callback, cb => {
    if (parallelValidate != null) {
      return cb(parallelValidate);
    }

    this.$__validate(pathsToValidate, options, (error) => {
      this.$op = null;
      cb(error);
    });
  }, this.constructor.events);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(pathsToValidate, options) {
  const _this = this;

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.schema.options.validateModifiedOnly;
  }

  if (typeof pathsToValidate === 'string') {
    pathsToValidate = pathsToValidate.split(' ');
  }

  // only validate required fields when necessary
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];

  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  }
  const validating = {};

  paths.forEach(function(path) {
    if (validating[path]) {
      return;
    }

    validating[path] = true;

    const p = _this.schema.path(path);
    if (!p) {
      return;
    }
    if (!_this.$isValid(path)) {
      return;
    }

    const val = _this.$__getValue(path);
    const err = p.doValidateSync(val, _this, {
      skipSchemaValidators: skipSchemaValidators[path],
      path: path
    });
    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
      if (p.$isSingleNested &&
          err instanceof ValidationError &&
          p.schema.options.storeSubdocValidationError === false) {
        return;
      }
      _this.invalidate(path, err, undefined, true);
    }
  });

  const err = _this.$__.validationError;
  _this.$__.validationError = undefined;
  _this.emit('validate', _this);
  _this.constructor.emit('validate', _this);

  if (err) {
    for (const key in err.errors) {
      // Make sure cast errors persist
      if (err.errors[key] instanceof MongooseError.CastError) {
        _this.invalidate(key, err.errors[key]);
      }
    }
  }

  return err;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function reset() {
  let _this = this;
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  this.$__.activePaths
    .map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    })
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    })
    .forEach(function(array) {
      let i = array.length;
      while (i--) {
        const doc = array[i];
        if (!doc) {
          continue;
        }
        doc.$__reset();
      }

      _this.$__.activePaths.init(array.$path());

      array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
      array[arrayAtomicsSymbol] = {};
    });

  this.$__.activePaths.
    map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    }).
    filter(function(val) {
      return val && val.$isSingleNested;
    }).
    forEach(function(doc) {
      doc.$__reset();
      _this.$__.activePaths.init(doc.$basePath);
    });

  // clear atomics
  this.$__dirty().forEach(function(dirt) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol]) {
      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
      type[arrayAtomicsSymbol] = {};
    }
  });

  this.$__.backup = {};
  this.$__.backup.activePaths = {
    modify: Object.assign({}, this.$__.activePaths.states.modify),
    default: Object.assign({}, this.$__.activePaths.states.default)
  };
  this.$__.backup.validationError = this.$__.validationError;
  this.$__.backup.errors = this.errors;

  // Clear 'dirty' cache
  this.$__.activePaths.clear('modify');
  this.$__.activePaths.clear('default');
  this.$__.validationError = undefined;
  this.errors = undefined;
  _this = this;
  this.schema.requiredPaths().forEach(function(path) {
    _this.$__.activePaths.require(path);
  });

  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function $__undoReset() {
  if (this.$__.backup == null || this.$__.backup.activePaths == null) {
    return;
  }

  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;

  this.$__.validationError = this.$__.backup.validationError;
  this.errors = this.$__.backup.errors;

  for (const dirt of this.$__dirty()) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
    }
  }

  for (const subdoc of this.$__getAllSubdocs()) {
    subdoc.$__undoReset();
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const _this = this;

  let all = this.$__.activePaths.map('modify', function(path) {
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  });

  // gh-2558: if we had to set a default and the value is not undefined,
  // we have to save as well
  all = all.concat(this.$__.activePaths.map('default', function(path) {
    if (path === '_id' || _this.$__getValue(path) == null) {
      return;
    }
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  }));

  // Sort dirty paths in a flat hierarchy.
  all.sort(function(a, b) {
    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
  });

  // Ignore "foo.a" if "foo" is dirty already.
  const minimal = [];
  let lastPath;
  let top;

  all.forEach(function(item) {
    if (!item) {
      return;
    }
    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {
      lastPath = item.path + '.';
      minimal.push(item);
      top = item;
    } else if (top != null &&
        top.value != null &&
        top.value[arrayAtomicsSymbol] != null &&
        top.value.hasAtomics()) {
      // special case for top level MongooseArrays
      // the `top` array itself and a sub path of `top` are being modified.
      // the only way to honor all of both modifications is through a $set
      // of entire array.
      top.value[arrayAtomicsSymbol] = {};
      top.value[arrayAtomicsSymbol].$set = top.value;
    }
  });

  top = lastPath = null;
  return minimal;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(schema) {
  schema.plugin(idGetter, { deduplicate: true });
  compile(schema.tree, this, undefined, schema.options);

  // Apply default getters if virtual doesn't have any (gh-6262)
  for (const key of Object.keys(schema.virtuals)) {
    schema.virtuals[key]._applyDefaultGetters();
  }

  this.schema = schema;
  this[documentSchemaSymbol] = schema;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  // validate all document arrays.
  return this.$__.activePaths
    .map('init', 'modify', function(i) {
      return this.$__getValue(i);
    }.bind(this))
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    }).reduce(function(seed, array) {
      return seed.concat(array);
    }, [])
    .filter(function(doc) {
      return doc;
    });
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));
  Embedded = Embedded || require('./types/embedded');

  function docReducer(doc, seed, path) {
    let val = doc;
    if (path) {
      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
        val = doc._doc[path];
      } else {
        val = doc[path];
      }
    }
    if (val instanceof Embedded) {
      seed.push(val);
    } else if (val instanceof Map) {
      seed = Array.from(val.keys()).reduce(function(seed, path) {
        return docReducer(val.get(path), seed, null);
      }, seed);
    } else if (val && val.$isSingleNested) {
      seed = Object.keys(val._doc).reduce(function(seed, path) {
        return docReducer(val._doc, seed, path);
      }, seed);
      seed.push(val);
    } else if (val && val.isMongooseDocumentArray) {
      val.forEach(function _docReduce(doc) {
        if (!doc || !doc._doc) {
          return;
        }
        seed = Object.keys(doc._doc).reduce(function(seed, path) {
          return docReducer(doc._doc, seed, path);
        }, seed);
        if (doc instanceof Embedded) {
          seed.push(doc);
        }
      });
    } else if (val instanceof Document && val.$__isNested) {
      seed = Object.keys(val).reduce(function(seed, path) {
        return docReducer(val, seed, path);
      }, seed);
    }
    return seed;
  }

  const _this = this;
  const subDocs = Object.keys(this._doc).reduce(function(seed, path) {
    return docReducer(_this, seed, path);
  }, []);

  return subDocs;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function handleReject(err) {
  // emit on the Model if listening
  if (this.listeners('error').length) {
    this.emit('error', err);
  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {
    this.constructor.emit('error', err);
  }
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options, json) {
  let defaultOptions = {
    transform: true,
    flattenDecimals: true
  };

  const path = json ? 'toJSON' : 'toObject';
  const baseOptions = get(this, 'constructor.base.options.' + path, {});
  const schemaOptions = get(this, 'schema.options', {});
  // merge base default options with Schema's set default options if available.
  // `clone` is necessary here because `utils.options` directly modifies the second input.
  defaultOptions = utils.options(defaultOptions, clone(baseOptions));
  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));

  // If options do not exist or is not an object, set it to empty object
  options = utils.isPOJO(options) ? clone(options) : {};
  options._calledWithOptions = options._calledWithOptions || clone(options);

  if (!('flattenMaps' in options)) {
    options.flattenMaps = defaultOptions.flattenMaps;
  }

  let _minimize;
  if (options._calledWithOptions.minimize != null) {
    _minimize = options.minimize;
  } else if (defaultOptions.minimize != null) {
    _minimize = defaultOptions.minimize;
  } else {
    _minimize = schemaOptions.minimize;
  }

  // The original options that will be passed to `clone()`. Important because
  // `clone()` will recursively call `$toObject()` on embedded docs, so we
  // need the original options the user passed in, plus `_isNested` and
  // `_parentOptions` for checking whether we need to depopulate.
  const cloneOptions = Object.assign(utils.clone(options), {
    _isNested: true,
    json: json,
    minimize: _minimize
  });

  if (utils.hasUserDefinedProperty(options, 'getters')) {
    cloneOptions.getters = options.getters;
  }
  if (utils.hasUserDefinedProperty(options, 'virtuals')) {
    cloneOptions.virtuals = options.virtuals;
  }

  const depopulate = options.depopulate ||
    get(options, '_parentOptions.depopulate', false);
  // _isNested will only be true if this is not the top level document, we
  // should never depopulate
  if (depopulate && options._isNested && this.$__.wasPopulated) {
    // populated paths that we set to a document
    return clone(this._id, cloneOptions);
  }

  // merge default options with input options.
  options = utils.options(defaultOptions, options);
  options._isNested = true;
  options.json = json;
  options.minimize = _minimize;

  cloneOptions._parentOptions = options;
  cloneOptions._skipSingleNestedGetters = true;

  const gettersOptions = Object.assign({}, cloneOptions);
  gettersOptions._skipSingleNestedGetters = false;

  // remember the root transform function
  // to save it from being overwritten by sub-transform functions
  const originalTransform = options.transform;

  let ret = clone(this._doc, cloneOptions) || {};

  if (options.getters) {
    applyGetters(this, ret, gettersOptions);

    if (options.minimize) {
      ret = minimize(ret) || {};
    }
  }

  if (options.virtuals || (options.getters && options.virtuals !== false)) {
    applyVirtuals(this, ret, gettersOptions, options);
  }

  if (options.versionKey === false && this.schema.options.versionKey) {
    delete ret[this.schema.options.versionKey];
  }

  let transform = options.transform;

  // In the case where a subdocument has its own transform function, we need to
  // check and see if the parent has a transform (options.transform) and if the
  // child schema has a transform (this.schema.options.toObject) In this case,
  // we need to adjust options.transform to be the child schema's transform and
  // not the parent schema's
  if (transform) {
    applySchemaTypeTransforms(this, ret);
  }

  if (options.useProjection) {
    omitDeselectedFields(this, ret);
  }

  if (transform === true || (schemaOptions.toObject && transform)) {
    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;

    if (opts) {
      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
    }
  } else {
    options.transform = originalTransform;
  }

  if (typeof transform === 'function') {
    const xformed = transform(this, ret, options);
    if (typeof xformed !== 'undefined') {
      ret = xformed;
    }
  }

  return ret;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  return this.$toObject(options);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(options) {
  return this.$toObject(options, true);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const ret = this.inspect();
  if (typeof ret === 'string') {
    return ret;
  }
  return inspect(ret);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(doc) {
  if (!doc) {
    return false;
  }

  const tid = this.$__getValue('_id');
  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;
  if (!tid && !docid) {
    return deepEqual(this, doc);
  }
  return tid && tid.equals
    ? tid.equals(docid)
    : tid === docid;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(callback) {
  const isUsingShorthand = callback != null && typeof callback !== 'function';
  if (isUsingShorthand) {
    return this.populate.apply(this, arguments).execPopulate();
  }

  return promiseOrCallback(callback, cb => {
    this.populate(cb);
  }, this.constructor.events);
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path, val, options) {
  // val and options are internal
  if (val === null || val === void 0) {
    if (!this.$__.populated) {
      return undefined;
    }
    const v = this.$__.populated[path];
    if (v) {
      return v.value;
    }
    return undefined;
  }

  // internal
  if (val === true) {
    if (!this.$__.populated) {
      return undefined;
    }
    return this.$__.populated[path];
  }

  this.$__.populated || (this.$__.populated = {});
  this.$__.populated[path] = { value: val, options: options };

  // If this was a nested populate, make sure each populated doc knows
  // about its populated children (gh-7685)
  const pieces = path.split('.');
  for (let i = 0; i < pieces.length - 1; ++i) {
    const subpath = pieces.slice(0, i + 1).join('.');
    const subdoc = this.get(subpath);
    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
      const rest = pieces.slice(i + 1).join('.');
      subdoc.populated(rest, val, options);
      // No need to continue because the above recursion should take care of
      // marking the rest of the docs as populated
      break;
    }
  }

  return val;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function(path) {
  if (typeof path === 'string') {
    path = path.split(' ');
  }

  let populatedIds;
  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
  const populated = get(this, '$__.populated', {});

  if (arguments.length === 0) {
    // Depopulate all
    for (const virtualKey of virtualKeys) {
      delete this.$$populatedVirtuals[virtualKey];
      delete this._doc[virtualKey];
      delete populated[virtualKey];
    }

    const keys = Object.keys(populated);

    for (const key of keys) {
      populatedIds = this.populated(key);
      if (!populatedIds) {
        continue;
      }
      delete populated[key];
      this.$set(key, populatedIds);
    }
    return this;
  }

  for (const singlePath of path) {
    populatedIds = this.populated(singlePath);
    delete populated[singlePath];

    if (virtualKeys.indexOf(singlePath) !== -1) {
      delete this.$$populatedVirtuals[singlePath];
      delete this._doc[singlePath];
    } else if (populatedIds) {
      this.$set(singlePath, populatedIds);
    }
  }
  return this;
}
                                              </td>
                                              
                                              <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: left; padding: 5px 5px;" align="left">
                                                  function() {
  const delta = this.$__delta();
  const changes = delta ? delta[1] : {};
  return changes;
}
                                              </td>
                                              
                                          </tr>
                                          
                                      </table>
                                    </td>
                                </tr>
                                </table>
                              
                            
                              <br>
                            <br>
                        </center></td>
                    </tr>
                </table>
                <table style="margin: 0 auto; border-collapse: collapse;" cellpadding="0" cellspacing="0" width="100%" bgcolor="#f5774e">
                  <tr>
                    <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center; color: #801F00;" align="center">
                      <center>
                        <table style="margin: 0 auto; border-collapse: collapse;" cellpadding="0" cellspacing="0" width="70%">
                          <tr>
                            <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center;" align="center">
                            <br>
                            <!-- Action -->
                            
                                <br>
                                <br>

                              
                                                                  Thank you for your answers!
                                  <br>
                                  <br>
                                                              

                              
                                Yours truly,
                                <br>
                                valentyna
                              

                              <br><br>
                            </td>
                          </tr>
                        </table>
                      </center>
                    </td>
                  </tr>
                  <tr>
                    <td style="font-family: Helvetica, Arial, sans-serif; font-weight: 400; text-align: center; background-color: #414141; color: #bbbbbb; padding: 22px 0 22px 0; font-size: 12px;" bgcolor="#414141" align="center">
                        &copy; 2021 <a href="http://intense-stream-90411.herokuapp.com" target="_blank" style="text-decoration: none; border: 0; outline: none; color: #bbbbbb;">valentyna</a>. All rights reserved.
                    </td>
                  </tr>
                </table>
            </td>
          </tr>
        </table>
    </center>
    </td>
  </tr>
</table>
</body>
</html>
